<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>于诗洋-Mr.Yu</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yushiyang.top/"/>
  <updated>2017-11-06T09:32:00.000Z</updated>
  <id>http://yushiyang.top/</id>
  
  <author>
    <name>于诗洋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>天天进步一点点AI篇--Deep Learning</title>
    <link href="http://yushiyang.top/2017/11/06/StudyEveryday-Deep%20Learning/"/>
    <id>http://yushiyang.top/2017/11/06/StudyEveryday-Deep Learning/</id>
    <published>2017-11-06T09:05:53.000Z</published>
    <updated>2017-11-06T09:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载至<a href="http://blog.csdn.net/zouxy09/article/details/8775360" target="_blank" rel="noopener">Deep Learning（深度学习）学习笔记整理系列</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Artificial Intelligence，也就是人工智能，就像长生不老和星际漫游一样，是人类最美好的梦想之一。虽然计算机技术已经取得了长足的进步，但是到目前为止，还没有一台电脑能产生“自我”的意识。是的，在人类和大量现成数据的帮助下，电脑可以表现的十分强大，但是离开了这两者，它甚至都不能分辨一个喵星人和一个汪星人。</p><p>​       图灵（图灵，大家都知道吧。计算机和人工智能的鼻祖，分别对应于其著名的“图灵机”和“图灵测试”）在 1950 年的论文里，提出图灵试验的设想，即，隔墙对话，你将不知道与你谈话的，是人还是电脑。这无疑给计算机，尤其是人工智能，预设了一个很高的期望值。但是半个世纪过去了，人工智能的进展，远远没有达到图灵试验的标准。这不仅让多年翘首以待的人们，心灰意冷，认为人工智能是忽悠，相关领域是“伪科学”。</p><p>​        但是自 2006 年以来，机器学习领域，取得了突破性的进展。图灵试验，至少不是那么可望而不可及了。至于技术手段，不仅仅依赖于云计算对大数据的并行处理能力，而且依赖于算法。这个算法就是，Deep Learning。借助于 Deep Learning 算法，人类终于找到了如何处理“抽象概念”这个亘古难题的方法。</p><p><img src="http://img.my.csdn.net/uploads/201304/08/1365435331_4283.jpg" alt="img"></p><p>​       2012年6月，《纽约时报》披露了Google Brain项目，吸引了公众的广泛关注。这个项目是由著名的斯坦福大学的机器学习教授Andrew Ng和在大规模计算机系统方面的世界顶尖专家JeffDean共同主导，用16000个CPU Core的并行计算平台训练一种称为“深度神经网络”（DNN，Deep Neural Networks）的机器学习模型（内部共有10亿个节点。这一网络自然是不能跟人类的神经网络相提并论的。要知道，人脑中可是有150多亿个神经元，互相连接的节点也就是突触数更是如银河沙数。曾经有人估算过，如果将一个人的大脑中所有神经细胞的轴突和树突依次连接起来，并拉成一根直线，可从地球连到月亮，再从月亮返回地球），在语音识别和图像识别等领域获得了巨大的成功。</p><p>​       项目负责人之一Andrew称：“我们没有像通常做的那样自己框定边界，而是直接把海量数据投放到算法中，让数据自己说话，系统会自动从数据中学习。”另外一名负责人Jeff则说：“我们在训练的时候从来不会告诉机器说：‘这是一只猫。’系统其实是自己发明或者领悟了“猫”的概念。”</p><p>  <img src="http://img.my.csdn.net/uploads/201304/08/1365435367_5076.jpg" alt="img"></p><p>​       2012年11月，微软在中国天津的一次活动上公开演示了一个全自动的同声传译系统，讲演者用英文演讲，后台的计算机一气呵成自动完成语音识别、英中机器翻译和中文语音合成，效果非常流畅。据报道，后面支撑的关键技术也是DNN，或者深度学习（DL，DeepLearning）。</p><p>​       2013年1月，在百度年会上，创始人兼CEO李彦宏高调宣布要成立百度研究院，其中第一个成立的就是“深度学习研究所”（IDL，Institue of Deep Learning）。</p><p> <img src="http://img.my.csdn.net/uploads/201304/08/1365435390_9783.jpg" alt="img"></p><p>​       为什么拥有大数据的互联网公司争相投入大量资源研发深度学习技术。听起来感觉deeplearning很牛那样。那什么是deep learning？为什么有deep learning？它是怎么来的？又能干什么呢？目前存在哪些困难呢？这些问题的简答都需要慢慢来。咱们先来了解下机器学习（人工智能的核心）的背景。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​      机器学习（Machine Learning）是一门专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能的学科。机器能否像人类一样能具有学习能力呢？1959年美国的塞缪尔(Samuel)设计了一个下棋程序，这个程序具有学习能力，它可以在不断的对弈中改善自己的棋艺。4年后，这个程序战胜了设计者本人。又过了3年，这个程序战胜了美国一个保持8年之久的常胜不败的冠军。这个程序向人们展示了机器学习的能力，提出了许多令人深思的社会问题与哲学问题（呵呵，人工智能正常的轨道没有很大的发展，这些什么哲学伦理啊倒发展的挺快。什么未来机器越来越像人，人越来越像机器啊。什么机器会反人类啊，ATM是开第一枪的啊等等。人类的思维无穷啊）。</p><p>​        机器学习虽然发展了几十年，但还是存在很多没有良好解决的问题：</p><p><img src="http://img.my.csdn.net/uploads/201304/08/1365435414_9821.jpg" alt="img"></p><p>​        例如图像识别、语音识别、自然语言理解、天气预测、基因表达、内容推荐等等。目前我们通过机器学习去解决这些问题的思路都是这样的（以视觉感知为例子）：</p><p><img src="http://img.my.csdn.net/uploads/201304/08/1365435432_2281.jpg" alt="img"></p><p>​        从开始的通过传感器（例如CMOS）来获得数据。然后经过预处理、特征提取、特征选择，再到推理、预测或者识别。最后一个部分，也就是机器学习的部分，绝大部分的工作是在这方面做的，也存在很多的paper和研究。</p><p>​        而中间的三部分，概括起来就是特征表达。良好的特征表达，对最终算法的准确性起了非常关键的作用，而且系统主要的计算和测试工作都耗在这一大部分。但，这块实际中一般都是人工完成的。靠人工提取特征。</p><p><img src="http://img.my.csdn.net/uploads/201304/08/1365435468_8350.jpg" alt="img"></p><p>​       截止现在，也出现了不少NB的特征（好的特征应具有不变性（大小、尺度和旋转等）和可区分性）：例如Sift的出现，是局部图像特征描述子研究领域一项里程碑式的工作。由于SIFT对尺度、旋转以及一定视角和光照变化等图像变化都具有不变性，并且SIFT具有很强的可区分性，的确让很多问题的解决变为可能。但它也不是万能的。</p><p><img src="http://img.my.csdn.net/uploads/201304/08/1365435491_6508.jpg" alt="img"></p><p>​       然而，手工地选取特征是一件非常费力、启发式（需要专业知识）的方法，能不能选取好很大程度上靠经验和运气，而且它的调节需要大量的时间。既然手工选取特征不太好，那么能不能自动地学习一些特征呢？答案是能！Deep Learning就是用来干这个事情的，看它的一个别名UnsupervisedFeature Learning，就可以顾名思义了，Unsupervised的意思就是不要人参与特征的选取过程。</p><p>​       那它是怎么学习的呢？怎么知道哪些特征好哪些不好呢？我们说机器学习是一门专门研究计算机怎样模拟或实现人类的学习行为的学科。好，那我们人的视觉系统是怎么工作的呢？为什么在茫茫人海，芸芸众生，滚滚红尘中我们都可以找到另一个她（因为，你存在我深深的脑海里，我的梦里 我的心里 我的歌声里……）。人脑那么NB，我们能不能参考人脑，模拟人脑呢？（好像和人脑扯上点关系的特征啊，算法啊，都不错，但不知道是不是人为强加的，为了使自己的作品变得神圣和高雅。）</p><p>​        近几十年以来，认知神经科学、生物学等等学科的发展，让我们对自己这个神秘的而又神奇的大脑不再那么的陌生。也给人工智能的发展推波助澜。</p><h2 id="人脑视觉机理"><a href="#人脑视觉机理" class="headerlink" title="人脑视觉机理"></a>人脑视觉机理</h2><p>​       1981 年的诺贝尔医学奖，颁发给了 David Hubel（出生于加拿大的美国神经生物学家） 和TorstenWiesel，以及 Roger Sperry。前两位的主要贡献，是“发现了视觉系统的信息处理”：可视皮层是分级的：</p><p><img src="http://img.my.csdn.net/uploads/201304/08/1365435513_7934.jpg" alt="img"></p><p>​        我们看看他们做了什么。1958 年，DavidHubel 和Torsten Wiesel 在 JohnHopkins University，研究瞳孔区域与大脑皮层神经元的对应关系。他们在猫的后脑头骨上，开了一个3 毫米的小洞，向洞里插入电极，测量神经元的活跃程度。</p><p>​      然后，他们在小猫的眼前，展现各种形状、各种亮度的物体。并且，在展现每一件物体时，还改变物体放置的位置和角度。他们期望通过这个办法，让小猫瞳孔感受不同类型、不同强弱的刺激。</p><p>​       之所以做这个试验，目的是去证明一个猜测。位于后脑皮层的不同视觉神经元，与瞳孔所受刺激之间，存在某种对应关系。一旦瞳孔受到某一种刺激，后脑皮层的某一部分神经元就会活跃。经历了很多天反复的枯燥的试验，同时牺牲了若干只可怜的小猫，David Hubel 和Torsten Wiesel 发现了一种被称为“方向选择性细胞（Orientation Selective Cell）”的神经元细胞。当瞳孔发现了眼前的物体的边缘，而且这个边缘指向某个方向时，这种神经元细胞就会活跃。</p><p>​       这个发现激发了人们对于神经系统的进一步思考。神经-中枢-大脑的工作过程，或许是一个不断迭代、不断抽象的过程。</p><p>​       这里的关键词有两个，一个是抽象，一个是迭代。从原始信号，做低级抽象，逐渐向高级抽象迭代。人类的逻辑思维，经常使用高度抽象的概念。</p><p>​        例如，从原始信号摄入开始（瞳孔摄入像素 Pixels），接着做初步处理（大脑皮层某些细胞发现边缘和方向），然后抽象（大脑判定，眼前的物体的形状，是圆形的），然后进一步抽象（大脑进一步判定该物体是只气球）。</p><p><img src="http://img.my.csdn.net/uploads/201304/08/1365435554_6921.jpg" alt="img"></p><p>​      这个生理学的发现，促成了计算机人工智能，在四十年后的突破性发展。</p><p>​      总的来说，人的视觉系统的信息处理是分级的。从低级的V1区提取边缘特征，再到V2区的形状或者目标的部分等，再到更高层，整个目标、目标的行为等。也就是说高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。例如，单词集合和句子的对应是多对一的，句子和语义的对应又是多对一的，语义和意图的对应还是多对一的，这是个层级体系。</p><p>​      敏感的人注意到关键词了：分层。而Deep learning的deep是不是就表示我存在多少层，也就是多深呢？没错。那Deep learning是如何借鉴这个过程的呢？毕竟是归于计算机来处理，面对的一个问题就是怎么对这个过程建模？</p><p>​       因为我们要学习的是特征的表达，那么关于特征，或者说关于这个层级特征，我们需要了解地更深入点。所以在说Deep Learning之前，我们有必要再啰嗦下特征（呵呵，实际上是看到那么好的对特征的解释，不放在这里有点可惜，所以就塞到这了）。</p><p>因为我们要学习的是特征的表达，那么关于特征，或者说关于这个层级特征，我们需要了解地更深入点。所以在说Deep Learning之前，我们有必要再啰嗦下特征（呵呵，实际上是看到那么好的对特征的解释，不放在这里有点可惜，所以就塞到这了）。</p><h2 id="关于特征"><a href="#关于特征" class="headerlink" title="关于特征"></a>关于特征</h2><p>​        特征是机器学习系统的原材料，对最终模型的影响是毋庸置疑的。如果数据被很好的表达成了特征，通常线性模型就能达到满意的精度。那对于特征，我们需要考虑什么呢？</p><h3 id="特征表示的粒度"><a href="#特征表示的粒度" class="headerlink" title="特征表示的粒度"></a>特征表示的粒度</h3><p>​        学习算法在一个什么粒度上的特征表示，才有能发挥作用？就一个图片来说，像素级的特征根本没有价值。例如下面的摩托车，从像素级别，根本得不到任何信息，其无法进行摩托车和非摩托车的区分。而如果特征是一个具有结构性（或者说有含义）的时候，比如是否具有车把手（handle），是否具有车轮（wheel），就很容易把摩托车和非摩托车区分，学习算法才能发挥作用。</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365438575_9396.jpg" alt="img"></p><p> <img src="http://img.my.csdn.net/uploads/201304/09/1365438590_4831.jpg" alt="img"></p><h3 id="初级（浅层）特征表示"><a href="#初级（浅层）特征表示" class="headerlink" title="初级（浅层）特征表示"></a>初级（浅层）特征表示</h3><p>​        既然像素级的特征表示方法没有作用，那怎样的表示才有用呢？</p><p>​        1995 年前后，Bruno Olshausen和 David Field 两位学者任职 Cornell University，他们试图同时用生理学和计算机的手段，双管齐下，研究视觉问题。</p><p>​        他们收集了很多黑白风景照片，从这些照片中，提取出400个小碎片，每个照片碎片的尺寸均为 16x16 像素，不妨把这400个碎片标记为 S[i], i = 0,.. 399。接下来，再从这些黑白风景照片中，随机提取另一个碎片，尺寸也是 16x16 像素，不妨把这个碎片标记为 T。</p><p>​        他们提出的问题是，如何从这400个碎片中，选取一组碎片，S[k], 通过叠加的办法，合成出一个新的碎片，而这个新的碎片，应当与随机选择的目标碎片 T，尽可能相似，同时，S[k] 的数量尽可能少。用数学的语言来描述，就是：</p><p>​        Sum_k (a[k] * S[k]) –&gt; T,     其中 a[k] 是在叠加碎片 S[k] 时的权重系数。</p><p>​        为解决这个问题，Bruno Olshausen和 David Field 发明了一个算法，稀疏编码（Sparse Coding）。</p><p>​        稀疏编码是一个重复迭代的过程，每次迭代分两步：</p><p>1）选择一组 S[k]，然后调整 a[k]，使得Sum_k (a[k] * S[k]) 最接近 T。</p><p>2）固定住 a[k]，在 400 个碎片中，选择其它更合适的碎片S’[k]，替代原先的 S[k]，使得Sum_k (a[k] * S’[k]) 最接近 T。</p><p>​        经过几次迭代后，最佳的 S[k] 组合，被遴选出来了。令人惊奇的是，被选中的 S[k]，基本上都是照片上不同物体的边缘线，这些线段形状相似，区别在于方向。</p><p>​        Bruno Olshausen和 David Field 的算法结果，与 David Hubel 和Torsten Wiesel 的生理发现，不谋而合！</p><p>​        也就是说，复杂图形，往往由一些基本结构组成。比如下图：一个图可以通过用64种正交的edges（可以理解成正交的基本结构）来线性表示。比如样例的x可以用1-64个edges中的三个按照0.8,0.3,0.5的权重调和而成。而其他基本edge没有贡献，因此均为0 。</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365438649_2577.jpg" alt="img"></p><p>​        另外，大牛们还发现，不仅图像存在这个规律，声音也存在。他们从未标注的声音中发现了20种基本的声音结构，其余的声音可以由这20种基本结构合成。</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365438664_7093.jpg" alt="img"></p><p><strong> <img src="http://img.my.csdn.net/uploads/201304/09/1365438678_4293.jpg" alt="img"></strong></p><hr><h3 id="结构性特征表示"><a href="#结构性特征表示" class="headerlink" title="结构性特征表示"></a>结构性特征表示</h3><p>​        小块的图形可以由基本edge构成，更结构化，更复杂的，具有概念性的图形如何表示呢？这就需要更高层次的特征表示，比如V2，V4。因此V1看像素级是像素级。V2看V1是像素级，这个是层次递进的，高层表达由底层表达的组合而成。专业点说就是基basis。V1取提出的basis是边缘，然后V2层是V1层这些basis的组合，这时候V2区得到的又是高一层的basis。即上一层的basis组合的结果，上上层又是上一层的组合basis……（所以有大牛说Deep learning就是“搞基”，因为难听，所以美其名曰Deep learning或者Unsupervised Feature Learning）</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365438722_9668.jpg" alt="img"></p><p>​        直观上说，就是找到make sense的小patch再将其进行combine，就得到了上一层的feature，递归地向上learning feature。</p><p>​        在不同object上做training是，所得的edge basis 是非常相似的，但object parts和models 就会completely different了（那咱们分辨car或者face是不是容易多了）：</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365438750_9009.jpg" alt="img"></p><p>​        从文本来说，一个doc表示什么意思？我们描述一件事情，用什么来表示比较合适？用一个一个字嘛，我看不是，字就是像素级别了，起码应该是term，换句话说每个doc都由term构成，但这样表示概念的能力就够了嘛，可能也不够，需要再上一步，达到topic级，有了topic，再到doc就合理。但每个层次的数量差距很大，比如doc表示的概念-&gt;topic（千-万量级）-&gt;term（10万量级）-&gt;word（百万量级）。</p><p>​        一个人在看一个doc的时候，眼睛看到的是word，由这些word在大脑里自动切词形成term，在按照概念组织的方式，先验的学习，得到topic，然后再进行高层次的learning。</p><h3 id="需要有多少个特征？"><a href="#需要有多少个特征？" class="headerlink" title="需要有多少个特征？"></a>需要有多少个特征？</h3><p>​       我们知道需要层次的特征构建，由浅入深，但每一层该有多少个特征呢？</p><p>任何一种方法，特征越多，给出的参考信息就越多，准确性会得到提升。但特征多意味着计算复杂，探索的空间大，可以用来训练的数据在每个特征上就会稀疏，都会带来各种问题，并不一定特征越多越好。</p><p> <img src="http://img.my.csdn.net/uploads/201304/09/1365438778_9193.jpg" alt="img"></p><p>​      </p><p>​       好了，到了这一步，终于可以聊到Deep learning了。上面我们聊到为什么会有Deep learning（让机器自动学习良好的特征，而免去人工选取过程。还有参考人的分层视觉处理系统），我们得到一个结论就是Deep learning需要多层来获得更抽象的特征表达。那么多少层才合适呢？用什么架构来建模呢？怎么进行非监督训练呢？</p><p> 好了，到了这一步，终于可以聊到Deep learning了。上面我们聊到为什么会有Deep learning（让机器自动学习良好的特征，而免去人工选取过程。还有参考人的分层视觉处理系统），我们得到一个结论就是Deep learning需要多层来获得更抽象的特征表达。那么多少层才合适呢？用什么架构来建模呢？怎么进行非监督训练呢？</p><h2 id="Deep-Learning的基本思想"><a href="#Deep-Learning的基本思想" class="headerlink" title="Deep Learning的基本思想"></a>Deep Learning的基本思想</h2><p>​       假设我们有一个系统S，它有n层（S1,…Sn），它的输入是I，输出是O，形象地表示为： I =&gt;S1=&gt;S2=&gt;…..=&gt;Sn =&gt; O，如果输出O等于输入I，即输入I经过这个系统变化之后没有任何的信息损失（呵呵，大牛说，这是不可能的。信息论中有个“信息逐层丢失”的说法（信息处理不等式），设处理a信息得到b，再对b处理得到c，那么可以证明：a和c的互信息不会超过a和b的互信息。这表明信息处理不会增加信息，大部分处理会丢失信息。当然了，如果丢掉的是没用的信息那多好啊），保持了不变，这意味着输入I经过每一层Si都没有任何的信息损失，即在任何一层Si，它都是原有信息（即输入I）的另外一种表示。现在回到我们的主题Deep Learning，我们需要自动地学习特征，假设我们有一堆输入I（如一堆图像或者文本），假设我们设计了一个系统S（有n层），我们通过调整系统中参数，使得它的输出仍然是输入I，那么我们就可以自动地获取得到输入I的一系列层次特征，即S1，…, Sn。</p><p>​       对于深度学习来说，其思想就是对堆叠多个层，也就是说这一层的输出作为下一层的输入。通过这种方式，就可以实现对输入信息进行分级表达了。</p><p>​       另外，前面是假设输出严格地等于输入，这个限制太严格，我们可以略微地放松这个限制，例如我们只要使得输入与输出的差别尽可能地小即可，这个放松会导致另外一类不同的Deep Learning方法。上述就是Deep Learning的基本思想。</p><h2 id="浅层学习（Shallow-Learning）和深度学习（Deep-Learning）"><a href="#浅层学习（Shallow-Learning）和深度学习（Deep-Learning）" class="headerlink" title="浅层学习（Shallow Learning）和深度学习（Deep Learning）"></a>浅层学习（Shallow Learning）和深度学习（Deep Learning）</h2><p><strong>       浅层学习是机器学习的第一次浪潮。</strong></p><p>​       20世纪80年代末期，用于人工神经网络的反向传播算法（也叫Back Propagation算法或者BP算法）的发明，给机器学习带来了希望，掀起了基于统计模型的机器学习热潮。这个热潮一直持续到今天。人们发现，利用BP算法可以让一个人工神经网络模型从大量训练样本中学习统计规律，从而对未知事件做预测。这种基于统计的机器学习方法比起过去基于人工规则的系统，在很多方面显出优越性。这个时候的人工神经网络，虽也被称作多层感知机（Multi-layer Perceptron），但实际是种只含有一层隐层节点的浅层模型。</p><p>​        20世纪90年代，各种各样的浅层机器学习模型相继被提出，例如支撑向量机（SVM，Support Vector Machines）、 Boosting、最大熵方法（如LR，Logistic Regression）等。这些模型的结构基本上可以看成带有一层隐层节点（如SVM、Boosting），或没有隐层节点（如LR）。这些模型无论是在理论分析还是应用中都获得了巨大的成功。相比之下，由于理论分析的难度大，训练方法又需要很多经验和技巧，这个时期浅层人工神经网络反而相对沉寂。</p><p><strong>        深度学习是机器学习的第二次浪潮。</strong></p><p>​        2006年，加拿大多伦多大学教授、机器学习领域的泰斗Geoffrey Hinton和他的学生RuslanSalakhutdinov在《科学》上发表了一篇文章，开启了深度学习在学术界和工业界的浪潮。这篇文章有两个主要观点：1）多隐层的人工神经网络具有优异的特征学习能力，学习得到的特征对数据有更本质的刻画，从而有利于可视化或分类；2）深度神经网络在训练上的难度，可以通过“逐层初始化”（layer-wise pre-training）来有效克服，在这篇文章中，逐层初始化是通过无监督学习实现的。</p><p>​        当前多数分类、回归等学习方法为浅层结构算法，其局限性在于有限样本和计算单元情况下对复杂函数的表示能力有限，针对复杂分类问题其泛化能力受到一定制约。深度学习可通过学习一种深层非线性网络结构，实现复杂函数逼近，表征输入数据分布式表示，并展现了强大的从少数样本集中学习数据集本质特征的能力。（多层的好处是可以用较少的参数表示复杂的函数）</p><p> <img src="http://img.my.csdn.net/uploads/201304/09/1365439310_9542.jpg" alt="img"></p><p>​        深度学习的实质，是通过构建具有很多隐层的机器学习模型和海量的训练数据，来学习更有用的特征，从而最终提升分类或预测的准确性。因此，“深度模型”是手段，“特征学习”是目的。区别于传统的浅层学习，深度学习的不同在于：1）强调了模型结构的深度，通常有5层、6层，甚至10多层的隐层节点；2）明确突出了特征学习的重要性，也就是说，通过逐层特征变换，将样本在原空间的特征表示变换到一个新特征空间，从而使分类或预测更加容易。与人工规则构造特征的方法相比，利用大数据来学习特征，更能够刻画数据的丰富内在信息。</p><h2 id="Deep-learning与Neural-Network"><a href="#Deep-learning与Neural-Network" class="headerlink" title="Deep learning与Neural Network"></a>Deep learning与Neural Network</h2><p>​        深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，例如图像，声音和文本。深度学习是无监督学习的一种。</p><p>​        深度学习的概念源于人工神经网络的研究。含多隐层的多层感知器就是一种深度学习结构。深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。</p><p>​       Deep learning本身算是machine learning的一个分支，简单可以理解为neural network的发展。大约二三十年前，neural network曾经是ML领域特别火热的一个方向，但是后来确慢慢淡出了，原因包括以下几个方面：</p><p>1）比较容易过拟合，参数比较难tune，而且需要不少trick；</p><p>2）训练速度比较慢，在层次比较少（小于等于3）的情况下效果并不比其它方法更优；</p><p>​       所以中间有大约20多年的时间，神经网络被关注很少，这段时间基本上是SVM和boosting算法的天下。但是，一个痴心的老先生Hinton，他坚持了下来，并最终（和其它人一起Bengio、Yann.lecun等）提成了一个实际可行的deep learning框架。</p><p>​        Deep learning与传统的神经网络之间有相同的地方也有很多不同。</p><p>​        二者的相同在于deep learning采用了神经网络相似的分层结构，系统由包括输入层、隐层（多层）、输出层组成的多层网络，只有相邻层节点之间有连接，同一层以及跨层节点之间相互无连接，每一层可以看作是一个logistic regression模型；这种分层结构，是比较接近人类大脑的结构的。</p><p> <img src="http://img.my.csdn.net/uploads/201304/09/1365439360_3108.jpg" alt="img"></p><p>​        而为了克服神经网络训练中的问题，DL采用了与神经网络很不同的训练机制。传统神经网络中，采用的是back propagation的方式进行，简单来讲就是采用迭代的算法来训练整个网络，随机设定初值，计算当前网络的输出，然后根据当前输出和label之间的差去改变前面各层的参数，直到收敛（整体是一个梯度下降法）。而deep learning整体上是一个layer-wise的训练机制。这样做的原因是因为，如果采用back propagation的机制，对于一个deep network（7层以上），残差传播到最前面的层已经变得太小，出现所谓的gradient diffusion（梯度扩散）。这个问题我们接下来讨论。</p><h2 id="Deep-learning训练过程"><a href="#Deep-learning训练过程" class="headerlink" title="Deep learning训练过程"></a>Deep learning训练过程</h2><h3 id="传统神经网络的训练方法为什么不能用在深度神经网络"><a href="#传统神经网络的训练方法为什么不能用在深度神经网络" class="headerlink" title="传统神经网络的训练方法为什么不能用在深度神经网络"></a>传统神经网络的训练方法为什么不能用在深度神经网络</h3><p>​       BP算法作为传统训练多层网络的典型算法，实际上对仅含几层网络，该训练方法就已经很不理想。深度结构（涉及多个非线性处理单元层）非凸目标代价函数中普遍存在的局部最小是训练困难的主要来源。</p><p><strong>BP算法存在的问题：</strong></p><p>（1）梯度越来越稀疏：从顶层越往下，误差校正信号越来越小；</p><p>（2）收敛到局部最小值：尤其是从远离最优区域开始的时候（随机值初始化会导致这种情况的发生）；</p><p>（3）一般，我们只能用有标签的数据来训练：但大部分的数据是没标签的，而大脑可以从没有标签的的数据中学习；</p><h3 id="deep-learning训练过程"><a href="#deep-learning训练过程" class="headerlink" title="deep learning训练过程"></a>deep learning训练过程</h3><p>​       如果对所有层同时训练，时间复杂度会太高；如果每次训练一层，偏差就会逐层传递。这会面临跟上面监督学习中相反的问题，会严重欠拟合（因为深度网络的神经元和参数太多了）。</p><p>​       2006年，hinton提出了在非监督数据上建立多层神经网络的一个有效方法，简单的说，分为两步，一是每次训练一层网络，二是调优，使原始表示x向上生成的高级表示r和该高级表示r向下生成的x’尽可能一致。方法是：</p><p>1）首先逐层构建单层神经元，这样每次都是训练一个单层网络。</p><p>2）当所有层训练完后，Hinton使用wake-sleep算法进行调优。</p><p>​       将除最顶层的其它层间的权重变为双向的，这样最顶层仍然是一个单层神经网络，而其它层则变为了图模型。向上的权重用于“认知”，向下的权重用于“生成”。然后使用Wake-Sleep算法调整所有的权重。让认知和生成达成一致，也就是保证生成的最顶层表示能够尽可能正确的复原底层的结点。比如顶层的一个结点表示人脸，那么所有人脸的图像应该激活这个结点，并且这个结果向下生成的图像应该能够表现为一个大概的人脸图像。Wake-Sleep算法分为醒（wake）和睡（sleep）两个部分。</p><p><strong>1）wake阶段</strong>：认知过程，通过外界的特征和向上的权重（认知权重）产生每一层的抽象表示（结点状态），并且使用梯度下降修改层间的下行权重（生成权重）。也就是“如果现实跟我想象的不一样，改变我的权重使得我想象的东西就是这样的”。</p><p><strong>2）sleep阶段</strong>：生成过程，通过顶层表示（醒时学得的概念）和向下权重，生成底层的状态，同时修改层间向上的权重。也就是“如果梦中的景象不是我脑中的相应概念，改变我的认知权重使得这种景象在我看来就是这个概念”。</p><p><strong>deep learning训练过程具体如下：</strong></p><p>1）使用自下上升非监督学习（就是从底层开始，一层一层的往顶层训练）：</p><p>​       采用无标定数据（有标定数据也可）分层训练各层参数，这一步可以看作是一个无监督训练过程，是和传统神经网络区别最大的部分（这个过程可以看作是feature learning过程）：</p><p>​       具体的，先用无标定数据训练第一层，训练时先学习第一层的参数（这一层可以看作是得到一个使得输出和输入差别最小的三层神经网络的隐层），由于模型capacity的限制以及稀疏性约束，使得得到的模型能够学习到数据本身的结构，从而得到比输入更具有表示能力的特征；在学习得到第n-1层后，将n-1层的输出作为第n层的输入，训练第n层，由此分别得到各层的参数；</p><p>2）自顶向下的监督学习（就是通过带标签的数据去训练，误差自顶向下传输，对网络进行微调）：</p><p>​       基于第一步得到的各层参数进一步fine-tune整个多层模型的参数，这一步是一个有监督训练过程；第一步类似神经网络的随机初始化初值过程，由于DL的第一步不是随机初始化，而是通过学习输入数据的结构得到的，因而这个初值更接近全局最优，从而能够取得更好的效果；所以deep learning效果好很大程度上归功于第一步的feature learning过程。</p><h2 id="Deep-Learning的常用模型或者方法"><a href="#Deep-Learning的常用模型或者方法" class="headerlink" title="Deep Learning的常用模型或者方法"></a>Deep Learning的常用模型或者方法</h2><h3 id="AutoEncoder自动编码器"><a href="#AutoEncoder自动编码器" class="headerlink" title="AutoEncoder自动编码器"></a>AutoEncoder自动编码器</h3><p>​        Deep Learning最简单的一种方法是利用人工神经网络的特点，人工神经网络（ANN）本身就是具有层次结构的系统，如果给定一个神经网络，我们假设其输出与输入是相同的，然后训练调整其参数，得到每一层中的权重。自然地，我们就得到了输入I的几种不同表示（每一层代表一种表示），这些表示就是特征。自动编码器就是一种尽可能复现输入信号的神经网络。为了实现这种复现，自动编码器就必须捕捉可以代表输入数据的最重要的因素，就像PCA那样，找到可以代表原信息的主要成分。</p><p>​       具体过程简单的说明如下：</p><p><strong>1）给定无标签数据，用非监督学习学习特征：</strong></p><p> <img src="http://img.my.csdn.net/uploads/201304/09/1365439723_4504.jpg" alt="img"></p><p>​       在我们之前的神经网络中，如第一个图，我们输入的样本是有标签的，即（input, target），这样我们根据当前输出和target（label）之间的差去改变前面各层的参数，直到收敛。但现在我们只有无标签数据，也就是右边的图。那么这个误差怎么得到呢？</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365439745_1862.jpg" alt="img"></p><p>​        如上图，我们将input输入一个encoder编码器，就会得到一个code，这个code也就是输入的一个表示，那么我们怎么知道这个code表示的就是input呢？我们加一个decoder解码器，这时候decoder就会输出一个信息，那么如果输出的这个信息和一开始的输入信号input是很像的（理想情况下就是一样的），那很明显，我们就有理由相信这个code是靠谱的。所以，我们就通过调整encoder和decoder的参数，使得重构误差最小，这时候我们就得到了输入input信号的第一个表示了，也就是编码code了。因为是无标签数据，所以误差的来源就是直接重构后与原输入相比得到。</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365439780_9725.jpg" alt="img"></p><p><strong>2）通过编码器产生特征，然后训练下一层。这样逐层训练：</strong></p><p>​       那上面我们就得到第一层的code，我们的重构误差最小让我们相信这个code就是原输入信号的良好表达了，或者牵强点说，它和原信号是一模一样的（表达不一样，反映的是一个东西）。那第二层和第一层的训练方式就没有差别了，我们将第一层输出的code当成第二层的输入信号，同样最小化重构误差，就会得到第二层的参数，并且得到第二层输入的code，也就是原输入信息的第二个表达了。其他层就同样的方法炮制就行了（训练这一层，前面层的参数都是固定的，并且他们的decoder已经没用了，都不需要了）。</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365439805_4681.jpg" alt="img"></p><p><strong>3）有监督微调：</strong></p><p>​      经过上面的方法，我们就可以得到很多层了。至于需要多少层（或者深度需要多少，这个目前本身就没有一个科学的评价方法）需要自己试验调了。每一层都会得到原始输入的不同的表达。当然了，我们觉得它是越抽象越好了，就像人的视觉系统一样。</p><p>​       到这里，这个AutoEncoder还不能用来分类数据，因为它还没有学习如何去连结一个输入和一个类。它只是学会了如何去重构或者复现它的输入而已。或者说，它只是学习获得了一个可以良好代表输入的特征，这个特征可以最大程度上代表原输入信号。那么，为了实现分类，我们就可以在AutoEncoder的最顶的编码层添加一个分类器（例如罗杰斯特回归、SVM等），然后通过标准的多层神经网络的监督训练方法（梯度下降法）去训练。</p><p>​        也就是说，这时候，我们需要将最后层的特征code输入到最后的分类器，通过有标签样本，通过监督学习进行微调，这也分两种，一个是只调整分类器（黑色部分）：</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365439828_1081.jpg" alt="img"></p><p>​       另一种：通过有标签样本，微调整个系统：（如果有足够多的数据，这个是最好的。end-to-end learning端对端学习）</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365439852_7450.jpg" alt="img"></p><p>​       一旦监督训练完成，这个网络就可以用来分类了。神经网络的最顶层可以作为一个线性分类器，然后我们可以用一个更好性能的分类器去取代它。</p><p>​       在研究中可以发现，如果在原有的特征中加入这些自动学习得到的特征可以大大提高精确度，甚至在分类问题中比目前最好的分类算法效果还要好！</p><p>​        AutoEncoder存在一些变体，这里简要介绍下两个：</p><p><strong>Sparse AutoEncoder稀疏自动编码器：</strong></p><p>​      当然，我们还可以继续加上一些约束条件得到新的Deep Learning方法，如：如果在AutoEncoder的基础上加上L1的Regularity限制（L1主要是约束每一层中的节点中大部分都要为0，只有少数不为0，这就是Sparse名字的来源），我们就可以得到Sparse AutoEncoder法。</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365439878_3585.jpg" alt="img"></p><p>​       如上图，其实就是限制每次得到的表达code尽量稀疏。因为稀疏的表达往往比其他的表达要有效（人脑好像也是这样的，某个输入只是刺激某些神经元，其他的大部分的神经元是受到抑制的）。</p><p><strong>Denoising AutoEncoders降噪自动编码器：</strong></p><p>​        降噪自动编码器DA是在自动编码器的基础上，训练数据加入噪声，所以自动编码器必须学习去去除这种噪声而获得真正的没有被噪声污染过的输入。因此，这就迫使编码器去学习输入信号的更加鲁棒的表达，这也是它的泛化能力比一般编码器强的原因。DA可以通过梯度下降算法去训练。</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365439902_7892.jpg" alt="img"></p><h3 id="Sparse-Coding稀疏编码"><a href="#Sparse-Coding稀疏编码" class="headerlink" title="Sparse Coding稀疏编码"></a>Sparse Coding稀疏编码</h3><p>​       如果我们把输出必须和输入相等的限制放松，同时利用线性代数中基的概念，即O = a1<em>Φ1 + a2</em>Φ2+….+ an*Φn， Φi是基，ai是系数，我们可以得到这样一个优化问题：</p><p>Min |I – O|，其中I表示输入，O表示输出。</p><p>​       通过求解这个最优化式子，我们可以求得系数ai和基Φi，这些系数和基就是输入的另外一种近似表达。</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365483354_9315.jpg" alt="img"></p><p>​       因此，它们可以用来表达输入I，这个过程也是自动学习得到的。如果我们在上述式子上加上L1的Regularity限制，得到：</p><p>Min |I – O| + u*(|a1| + |a2| + … + |an |)</p><p>​        这种方法被称为Sparse Coding。通俗的说，就是将一个信号表示为一组基的线性组合，而且要求只需要较少的几个基就可以将信号表示出来。“稀疏性”定义为：只有很少的几个非零元素或只有很少的几个远大于零的元素。要求系数 ai 是稀疏的意思就是说：对于一组输入向量，我们只想有尽可能少的几个系数远大于零。选择使用具有稀疏性的分量来表示我们的输入数据是有原因的，因为绝大多数的感官数据，比如自然图像，可以被表示成少量基本元素的叠加，在图像中这些基本元素可以是面或者线。同时，比如与初级视觉皮层的类比过程也因此得到了提升（人脑有大量的神经元，但对于某些图像或者边缘只有很少的神经元兴奋，其他都处于抑制状态）。</p><p>​         稀疏编码算法是一种无监督学习方法，它用来寻找一组“超完备”基向量来更高效地表示样本数据。虽然形如主成分分析技术（PCA）能使我们方便地找到一组“完备”基向量，但是这里我们想要做的是找到一组“超完备”基向量来表示输入向量（也就是说，基向量的个数比输入向量的维数要大）。超完备基的好处是它们能更有效地找出隐含在输入数据内部的结构与模式。然而，对于超完备基来说，系数ai不再由输入向量唯一确定。因此，在稀疏编码算法中，我们另加了一个评判标准“稀疏性”来解决因超完备而导致的退化（degeneracy）问题。（<a href="http://deeplearning.stanford.edu/wiki/index.php/%E7%A8%80%E7%96%8F%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">详细过程请参考：UFLDL Tutorial稀疏编码</a>）</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365483386_5095.jpg" alt="img"></p><p>​       比如在图像的Feature Extraction的最底层要做Edge Detector的生成，那么这里的工作就是从Natural Images中randomly选取一些小patch，通过这些patch生成能够描述他们的“基”，也就是右边的8*8=64个basis组成的basis，然后给定一个test patch, 我们可以按照上面的式子通过basis的线性组合得到，而sparse matrix就是a，下图中的a中有64个维度，其中非零项只有3个，故称“sparse”。</p><p>​       这里可能大家会有疑问，为什么把底层作为Edge Detector呢？上层又是什么呢？这里做个简单解释大家就会明白，之所以是Edge Detector是因为不同方向的Edge就能够描述出整幅图像，所以不同方向的Edge自然就是图像的basis了……而上一层的basis组合的结果，上上层又是上一层的组合basis……（就是上面第四部分的时候咱们说的那样）</p><p>​       Sparse coding分为两个部分：</p><p><strong>1）Training阶段：</strong>给定一系列的样本图片[x1, x 2, …]，我们需要学习得到一组基[Φ1, Φ2, …]，也就是字典。</p><p>​       稀疏编码是k-means算法的变体，其训练过程也差不多（EM算法的思想：如果要优化的目标函数包含两个变量，如L(W, B)，那么我们可以先固定W，调整B使得L最小，然后再固定B，调整W使L最小，这样迭代交替，不断将L推向最小值。EM算法可以见我的博客：“<a href="http://blog.csdn.net/zouxy09/article/details/8537620" target="_blank" rel="noopener">从最大似然到EM算法浅解</a>”）。</p><p>​       训练过程就是一个重复迭代的过程，按上面所说，我们交替的更改a和Φ使得下面这个目标函数最小。</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365483429_5706.jpg" alt="img"></p><p>​      每次迭代分两步：</p><p>a）固定字典Φ[k]，然后调整a[k]，使得上式，即目标函数最小（即解LASSO问题）。</p><p>b）然后固定住a [k]，调整Φ [k]，使得上式，即目标函数最小（即解凸QP问题）。</p><p>​      不断迭代，直至收敛。这样就可以得到一组可以良好表示这一系列x的基，也就是字典。</p><p><strong>2）Coding阶段：</strong>给定一个新的图片x，由上面得到的字典，通过解一个LASSO问题得到稀疏向量<strong>a</strong>。这个稀疏向量就是这个输入向量x的一个稀疏表达了。</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365483467_1398.jpg" alt="img"></p><p>例如：</p><p><img src="http://img.my.csdn.net/uploads/201304/09/1365483491_9524.jpg" alt="img"></p><h3 id="Restricted-Boltzmann-Machine-RBM-限制波尔兹曼机"><a href="#Restricted-Boltzmann-Machine-RBM-限制波尔兹曼机" class="headerlink" title="Restricted Boltzmann Machine (RBM)限制波尔兹曼机"></a>Restricted Boltzmann Machine (RBM)限制波尔兹曼机</h3><p>​       假设有一个二部图，每一层的节点之间没有链接，一层是可视层，即输入数据层（v)，一层是隐藏层(h)，如果假设所有的节点都是随机二值变量节点（只能取0或者1值），同时假设全概率分布p(v,h)满足Boltzmann 分布，我们称这个模型是Restricted BoltzmannMachine (RBM)。</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561323_7932.jpg" alt="img"></p><p>​       下面我们来看看为什么它是Deep Learning方法。首先，这个模型因为是二部图，所以在已知v的情况下，所有的隐藏节点之间是条件独立的（因为节点之间不存在连接），即p(h|v)=p(h1|v)…p(hn|v)。同理，在已知隐藏层h的情况下，所有的可视节点都是条件独立的。同时又由于所有的v和h满足Boltzmann 分布，因此，当输入v的时候，通过p(h|v) 可以得到隐藏层h，而得到隐藏层h之后，通过p(v|h)又能得到可视层，通过调整参数，我们就是要使得从隐藏层得到的可视层v1与原来的可视层v如果一样，那么得到的隐藏层就是可视层另外一种表达，因此隐藏层可以作为可视层输入数据的特征，所以它就是一种Deep Learning方法。</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561362_2427.jpg" alt="img"></p><p>​       如何训练呢？也就是可视层节点和隐节点间的权值怎么确定呢？我们需要做一些数学分析。也就是模型了。</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561384_7276.jpg" alt="img"></p><p>​        联合组态（jointconfiguration）的能量可以表示为：</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561400_3303.jpg" alt="img"></p><p>​        而某个组态的联合概率分布可以通过Boltzmann 分布（和这个组态的能量）来确定：</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561427_1491.jpg" alt="img"></p><p>​      因为隐藏节点之间是条件独立的（因为节点之间不存在连接），即：</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561464_9047.jpg" alt="img"></p><p>​      然后我们可以比较容易（对上式进行因子分解Factorizes）得到在给定可视层v的基础上，隐层第j个节点为1或者为0的概率：</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561492_4178.jpg" alt="img"></p><p>​       同理，在给定隐层h的基础上，可视层第i个节点为1或者为0的概率也可以容易得到：</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561523_2700.jpg" alt="img"></p><p>​       给定一个满足独立同分布的样本集：D={<strong>v</strong>(1),<strong> v</strong>(2),…,<strong> v</strong>(N)}，我们需要学习参数θ={W,a,b}。</p><p>​       我们最大化以下对数似然函数（最大似然估计：对于某个概率模型，我们需要选择一个参数，让我们当前的观测样本的概率最大）：</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561551_7458.jpg" alt="img"></p><p>​        也就是对最大对数似然函数求导，就可以得到L最大时对应的参数W了。</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561570_5666.jpg" alt="img"></p><hr><p>​       如果，我们把隐藏层的层数增加，我们可以得到Deep Boltzmann Machine(DBM)；如果我们在靠近可视层的部分使用贝叶斯信念网络（即有向图模型，当然这里依然限制层中节点之间没有链接），而在最远离可视层的部分使用Restricted Boltzmann Machine，我们可以得到DeepBelief Net（DBN）。</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561611_3496.jpg" alt="img"></p><h3 id="Deep-Belief-Networks深信度网络"><a href="#Deep-Belief-Networks深信度网络" class="headerlink" title="Deep Belief Networks深信度网络"></a>Deep Belief Networks深信度网络</h3><p>​        DBNs是一个概率生成模型，与传统的判别模型的神经网络相对，生成模型是建立一个观察数据和标签之间的联合分布，对P(Observation|Label)和 P(Label|Observation)都做了评估，而判别模型仅仅而已评估了后者，也就是P(Label|Observation)。对于在深度神经网络应用传统的BP算法的时候，DBNs遇到了以下问题：</p><p>（1）需要为训练提供一个有标签的样本集；</p><p>（2）学习过程较慢；</p><p>（3）不适当的参数选择会导致学习收敛于局部最优解。</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561636_9432.jpg" alt="img"></p><p>​       DBNs由多个限制玻尔兹曼机（Restricted Boltzmann Machines）层组成，一个典型的神经网络类型如图三所示。这些网络被“限制”为一个可视层和一个隐层，层间存在连接，但层内的单元间不存在连接。隐层单元被训练去捕捉在可视层表现出来的高阶数据的相关性。</p><p>​       首先，先不考虑最顶构成一个联想记忆（associative memory）的两层，一个DBN的连接是通过自顶向下的生成权值来指导确定的，RBMs就像一个建筑块一样，相比传统和深度分层的sigmoid信念网络，它能易于连接权值的学习。</p><p>​       最开始的时候，通过一个非监督贪婪逐层方法去预训练获得生成模型的权值，非监督贪婪逐层方法被Hinton证明是有效的，并被其称为对比分歧（contrastive divergence）。</p><p>​       在这个训练阶段，在可视层会产生一个向量v，通过它将值传递到隐层。反过来，可视层的输入会被随机的选择，以尝试去重构原始的输入信号。最后，这些新的可视的神经元激活单元将前向传递重构隐层激活单元，获得h（在训练过程中，首先将可视向量值映射给隐单元；然后可视单元由隐层单元重建；这些新可视单元再次映射给隐单元，这样就获取新的隐单元。执行这种反复步骤叫做吉布斯采样）。这些后退和前进的步骤就是我们熟悉的Gibbs采样，而隐层激活单元和可视层输入之间的相关性差别就作为权值更新的主要依据。</p><p>​       训练时间会显著的减少，因为只需要单个步骤就可以接近最大似然学习。增加进网络的每一层都会改进训练数据的对数概率，我们可以理解为越来越接近能量的真实表达。这个有意义的拓展，和无标签数据的使用，是任何一个深度学习应用的决定性的因素。</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365561659_1933.jpg" alt="img"></p><p>​       在最高两层，权值被连接到一起，这样更低层的输出将会提供一个参考的线索或者关联给顶层，这样顶层就会将其联系到它的记忆内容。而我们最关心的，最后想得到的就是判别性能，例如分类任务里面。</p><p>​       在预训练后，DBN可以通过利用带标签数据用BP算法去对判别性能做调整。在这里，一个标签集将被附加到顶层（推广联想记忆），通过一个自下向上的，学习到的识别权值获得一个网络的分类面。这个性能会比单纯的BP算法训练的网络好。这可以很直观的解释，DBNs的BP算法只需要对权值参数空间进行一个局部的搜索，这相比前向神经网络来说，训练是要快的，而且收敛的时间也少。</p><p>​       DBNs的灵活性使得它的拓展比较容易。一个拓展就是卷积DBNs（Convolutional Deep Belief Networks(CDBNs)）。DBNs并没有考虑到图像的2维结构信息，因为输入是简单的从一个图像矩阵一维向量化的。而CDBNs就是考虑到了这个问题，它利用邻域像素的空域关系，通过一个称为卷积RBMs的模型区达到生成模型的变换不变性，而且可以容易得变换到高维图像。DBNs并没有明确地处理对观察变量的时间联系的学习上，虽然目前已经有这方面的研究，例如堆叠时间RBMs，以此为推广，有序列学习的dubbed temporal convolutionmachines，这种序列学习的应用，给语音信号处理问题带来了一个让人激动的未来研究方向。</p><p>​       目前，和DBNs有关的研究包括堆叠自动编码器，它是通过用堆叠自动编码器来替换传统DBNs里面的RBMs。这就使得可以通过同样的规则来训练产生深度多层神经网络架构，但它缺少层的参数化的严格要求。与DBNs不同，自动编码器使用判别模型，这样这个结构就很难采样输入采样空间，这就使得网络更难捕捉它的内部表达。但是，降噪自动编码器却能很好的避免这个问题，并且比传统的DBNs更优。它通过在训练过程添加随机的污染并堆叠产生场泛化性能。训练单一的降噪自动编码器的过程和RBMs训练生成模型的过程一样。</p><h3 id="Convolutional-Neural-Networks卷积神经网络"><a href="#Convolutional-Neural-Networks卷积神经网络" class="headerlink" title="Convolutional Neural Networks卷积神经网络"></a>Convolutional Neural Networks卷积神经网络</h3><p>​       卷积神经网络是人工神经网络的一种，已成为当前语音分析和图像识别领域的研究热点。它的权值共享网络结构使之更类似于生物神经网络，降低了网络模型的复杂度，减少了权值的数量。该优点在网络的输入是多维图像时表现的更为明显，使图像可以直接作为网络的输入，避免了传统识别算法中复杂的特征提取和数据重建过程。卷积网络是为识别二维形状而特殊设计的一个多层感知器，这种网络结构对平移、比例缩放、倾斜或者共他形式的变形具有高度不变性。</p><p>​       CNNs是受早期的延时神经网络（TDNN）的影响。延时神经网络通过在时间维度上共享权值降低学习复杂度，适用于语音和时间序列信号的处理。</p><p>​       CNNs是第一个真正成功训练多层网络结构的学习算法。它利用空间关系减少需要学习的参数数目以提高一般前向BP算法的训练性能。CNNs作为一个深度学习架构提出是为了最小化数据的预处理要求。在CNN中，图像的一小部分（局部感受区域）作为层级结构的最低层的输入，信息再依次传输到不同的层，每层通过一个数字滤波器去获得观测数据的最显著的特征。这个方法能够获取对平移、缩放和旋转不变的观测数据的显著特征，因为图像的局部感受区域允许神经元或者处理单元可以访问到最基础的特征，例如定向边缘或者角点。</p><p><strong>1）卷积神经网络的历史</strong></p><p>​       1962年Hubel和Wiesel通过对猫视觉皮层细胞的研究，提出了感受野(receptive field)的概念，1984年日本学者Fukushima基于感受野概念提出的神经认知机(neocognitron)可以看作是卷积神经网络的第一个实现网络，也是感受野概念在人工神经网络领域的首次应用。神经认知机将一个视觉模式分解成许多子模式（特征），然后进入分层递阶式相连的特征平面进行处理，它试图将视觉系统模型化，使其能够在即使物体有位移或轻微变形的时候，也能完成识别。</p><p>​       通常神经认知机包含两类神经元，即承担特征抽取的S-元和抗变形的C-元。S-元中涉及两个重要参数，即感受野与阈值参数，前者确定输入连接的数目，后者则控制对特征子模式的反应程度。许多学者一直致力于提高神经认知机的性能的研究：在传统的神经认知机中，每个S-元的感光区中由C-元带来的视觉模糊量呈正态分布。如果感光区的边缘所产生的模糊效果要比中央来得大，S-元将会接受这种非正态模糊所导致的更大的变形容忍性。我们希望得到的是，训练模式与变形刺激模式在感受野的边缘与其中心所产生的效果之间的差异变得越来越大。为了有效地形成这种非正态模糊，Fukushima提出了带双C-元层的改进型神经认知机。</p><p>​       Van Ooyen和Niehuis为提高神经认知机的区别能力引入了一个新的参数。事实上，该参数作为一种抑制信号，抑制了神经元对重复激励特征的激励。多数神经网络在权值中记忆训练信息。根据Hebb学习规则，某种特征训练的次数越多，在以后的识别过程中就越容易被检测。也有学者将进化计算理论与神经认知机结合，通过减弱对重复性激励特征的训练学习，而使得网络注意那些不同的特征以助于提高区分能力。上述都是神经认知机的发展过程，而卷积神经网络可看作是神经认知机的推广形式，神经认知机是卷积神经网络的一种特例。</p><p><strong>2）卷积神经网络的网络结构</strong></p><p>​      卷积神经网络是一个多层的神经网络，每层由多个二维平面组成，而每个平面由多个独立神经元组成。</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365562094_2229.jpg" alt="img"></p><p>​       图：卷积神经网络的概念示范：输入图像通过和三个可训练的滤波器和可加偏置进行卷积，滤波过程如图一，卷积后在C1层产生三个特征映射图，然后特征映射图中每组的四个像素再进行求和，加权值，加偏置，通过一个Sigmoid函数得到三个S2层的特征映射图。这些映射图再进过滤波得到C3层。这个层级结构再和S2一样产生S4。最终，这些像素值被光栅化，并连接成一个向量输入到传统的神经网络，得到输出。</p><p>​       一般地，C层为特征提取层，每个神经元的输入与前一层的局部感受野相连，并提取该局部的特征，一旦该局部特征被提取后，它与其他特征间的位置关系也随之确定下来；S层是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射为一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。</p><p>​       此外，由于一个映射面上的神经元共享权值，因而减少了网络自由参数的个数，降低了网络参数选择的复杂度。卷积神经网络中的每一个特征提取层（C-层）都紧跟着一个用来求局部平均与二次提取的计算层（S-层），这种特有的两次特征提取结构使网络在识别时对输入样本有较高的畸变容忍能力。</p><p><strong>3）关于参数减少与权值共享</strong></p><p>​      上面聊到，好像CNN一个牛逼的地方就在于通过感受野和权值共享减少了神经网络需要训练的参数的个数。那究竟是啥的呢？</p><p>​       下图左：如果我们有1000x1000像素的图像，有1百万个隐层神经元，那么他们全连接的话（每个隐层神经元都连接图像的每一个像素点），就有1000x1000x1000000=10^12个连接，也就是10^12个权值参数。然而图像的空间联系是局部的，就像人是通过一个局部的感受野去感受外界图像一样，每一个神经元都不需要对全局图像做感受，每个神经元只感受局部的图像区域，然后在更高层，将这些感受不同局部的神经元综合起来就可以得到全局的信息了。这样，我们就可以减少连接的数目，也就是减少神经网络需要训练的权值参数的个数了。如下图右：假如局部感受野是10x10，隐层每个感受野只需要和这10x10的局部图像相连接，所以1百万个隐层神经元就只有一亿个连接，即10^8个参数。比原来减少了四个0（数量级），这样训练起来就没那么费力了，但还是感觉很多的啊，那还有啥办法没？</p><p> <img src="http://img.my.csdn.net/uploads/201304/10/1365562155_9356.jpg" alt="img"></p><p>​       我们知道，隐含层的每一个神经元都连接10x10个图像区域，也就是说每一个神经元存在10x10=100个连接权值参数。那如果我们每个神经元这100个参数是相同的呢？也就是说每个神经元用的是同一个卷积核去卷积图像。这样我们就只有多少个参数？？只有100个参数啊！！！亲！不管你隐层的神经元个数有多少，两层间的连接我只有100个参数啊！亲！这就是权值共享啊！亲！这就是卷积神经网络的主打卖点啊！亲！（有点烦了，呵呵）也许你会问，这样做靠谱吗？为什么可行呢？这个……共同学习。</p><p>​       好了，你就会想，这样提取特征也忒不靠谱吧，这样你只提取了一种特征啊？对了，真聪明，我们需要提取多种特征对不？假如一种滤波器，也就是一种卷积核就是提出图像的一种特征，例如某个方向的边缘。那么我们需要提取不同的特征，怎么办，加多几种滤波器不就行了吗？对了。所以假设我们加到100种滤波器，每种滤波器的参数不一样，表示它提出输入图像的不同特征，例如不同的边缘。这样每种滤波器去卷积图像就得到对图像的不同特征的放映，我们称之为Feature Map。所以100种卷积核就有100个Feature Map。这100个Feature Map就组成了一层神经元。到这个时候明了了吧。我们这一层有多少个参数了？100种卷积核x每种卷积核共享100个参数=100x100=10K，也就是1万个参数。才1万个参数啊！亲！（又来了，受不了了！）见下图右：不同的颜色表达不同的滤波器。</p><p> <img src="http://img.my.csdn.net/uploads/201304/10/1365562217_2880.jpg" alt="img"></p><p>​       嘿哟，遗漏一个问题了。刚才说隐层的参数个数和隐层的神经元个数无关，只和滤波器的大小和滤波器种类的多少有关。那么隐层的神经元个数怎么确定呢？它和原图像，也就是输入的大小（神经元个数）、滤波器的大小和滤波器在图像中的滑动步长都有关！例如，我的图像是1000x1000像素，而滤波器大小是10x10，假设滤波器没有重叠，也就是步长为10，这样隐层的神经元个数就是(1000x1000 )/ (10x10)=100x100个神经元了，假设步长是8，也就是卷积核会重叠两个像素，那么……我就不算了，思想懂了就好。注意了，这只是一种滤波器，也就是一个Feature Map的神经元个数哦，如果100个Feature Map就是100倍了。由此可见，图像越大，神经元个数和需要训练的权值参数个数的贫富差距就越大。</p><p> <img src="http://img.my.csdn.net/uploads/201304/10/1365562245_8389.jpg" alt="img"></p><p>​      需要注意的一点是，上面的讨论都没有考虑每个神经元的偏置部分。所以权值个数需要加1 。这个也是同一种滤波器共享的。</p><p>​      总之，卷积网络的核心思想是将：局部感受野、权值共享（或者权值复制）以及时间或空间亚采样这三种结构思想结合起来获得了某种程度的位移、尺度、形变不变性。</p><p><strong>4）一个典型的例子说明</strong></p><p>​       一种典型的用来识别数字的卷积网络是LeNet-5（<a href="http://yann.lecun.com/exdb/lenet/index.html" target="_blank" rel="noopener">效果和paper等见这</a>）。当年美国大多数银行就是用它来识别支票上面的手写数字的。能够达到这种商用的地步，它的准确性可想而知。毕竟目前学术界和工业界的结合是最受争议的。</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365562301_9590.jpg" alt="img"></p><p>​      那下面咱们也用这个例子来说明下。</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365562321_2400.jpg" alt="img"></p><p>​        LeNet-5共有7层，不包含输入，每层都包含可训练参数（连接权重）。输入图像为32*32大小。这要比<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">Mnist数据库</a>（一个公认的手写数据库）中最大的字母还大。这样做的原因是希望潜在的明显特征如笔画断电或角点能够出现在最高层特征监测子感受野的中心。</p><p>​        我们先要明确一点：每个层有多个Feature Map，每个Feature Map通过一种卷积滤波器提取输入的一种特征，然后每个Feature Map有多个神经元。</p><p>​        C1层是一个卷积层（为什么是卷积？卷积运算一个重要的特点就是，通过卷积运算，可以使原信号特征增强，并且降低噪音），由6个特征图Feature Map构成。特征图中每个神经元与输入中5<em>5的邻域相连。特征图的大小为28</em>28，这样能防止输入的连接掉到边界之外（是为了BP反馈时的计算，不致梯度损失，个人见解）。C1有156个可训练参数（每个滤波器5<em>5=25个unit参数和一个bias参数，一共6个滤波器，共(5</em>5+1)<em>6=156个参数），共156</em>(28*28)=122,304个连接。</p><p>​       S2层是一个下采样层（为什么是下采样？利用图像局部相关性的原理，对图像进行子抽样，可以减少数据处理量同时保留有用信息），有6个14<em>14的特征图。特征图中的每个单元与C1中相对应特征图的2</em>2邻域相连接。S2层每个单元的4个输入相加，乘以一个可训练参数，再加上一个可训练偏置。结果通过sigmoid函数计算。可训练系数和偏置控制着sigmoid函数的非线性程度。如果系数比较小，那么运算近似于线性运算，亚采样相当于模糊图像。如果系数比较大，根据偏置的大小亚采样可以被看成是有噪声的“或”运算或者有噪声的“与”运算。每个单元的2*2感受野并不重叠，因此S2中每个特征图的大小是C1中特征图大小的1/4（行和列各1/2）。S2层有12个可训练参数和5880个连接。</p><p><img src="http://img.my.csdn.net/uploads/201304/10/1365562371_3221.jpg" alt="img"></p><p>图：卷积和子采样过程：卷积过程包括：用一个可训练的滤波器fx去卷积一个输入的图像（第一阶段是输入的图像，后面的阶段就是卷积特征map了），然后加一个偏置bx，得到卷积层Cx。子采样过程包括：每邻域四个像素求和变为一个像素，然后通过标量Wx+1加权，再增加偏置bx+1，然后通过一个sigmoid激活函数，产生一个大概缩小四倍的特征映射图Sx+1。</p><p>​       所以从一个平面到下一个平面的映射可以看作是作卷积运算，S-层可看作是模糊滤波器，起到二次特征提取的作用。隐层与隐层之间空间分辨率递减，而每层所含的平面数递增，这样可用于检测更多的特征信息。</p><p>​       C3层也是一个卷积层，它同样通过5x5的卷积核去卷积层S2，然后得到的特征map就只有10x10个神经元，但是它有16种不同的卷积核，所以就存在16个特征map了。这里需要注意的一点是：C3中的每个特征map是连接到S2中的所有6个或者几个特征map的，表示本层的特征map是上一层提取到的特征map的不同组合（这个做法也并不是唯一的）。（看到没有，这里是组合，就像之前聊到的人的视觉系统一样，底层的结构构成上层更抽象的结构，例如边缘构成形状或者目标的部分）。</p><p>​       刚才说C3中每个特征图由S2中所有6个或者几个特征map组合而成。为什么不把S2中的每个特征图连接到每个C3的特征图呢？原因有2点。第一，不完全的连接机制将连接的数量保持在合理的范围内。第二，也是最重要的，其破坏了网络的对称性。由于不同的特征图有不同的输入，所以迫使他们抽取不同的特征（希望是互补的）。</p><p>​      例如，存在的一个方式是：C3的前6个特征图以S2中3个相邻的特征图子集为输入。接下来6个特征图以S2中4个相邻特征图子集为输入。然后的3个以不相邻的4个特征图子集为输入。最后一个将S2中所有特征图为输入。这样C3层有1516个可训练参数和151600个连接。</p><p>​       S4层是一个下采样层，由16个5<em>5大小的特征图构成。特征图中的每个单元与C3中相应特征图的2</em>2邻域相连接，跟C1和S2之间的连接一样。S4层有32个可训练参数（每个特征图1个因子和一个偏置）和2000个连接。</p><p>​       C5层是一个卷积层，有120个特征图。每个单元与S4层的全部16个单元的5<em>5邻域相连。由于S4层特征图的大小也为5</em>5（同滤波器一样），故C5特征图的大小为1<em>1：这构成了S4和C5之间的全连接。之所以仍将C5标示为卷积层而非全相联层，是因为如果LeNet-5的输入变大，而其他的保持不变，那么此时特征图的维数就会比1</em>1大。C5层有48120个可训练连接。</p><p>​        F6层有84个单元（之所以选这个数字的原因来自于输出层的设计），与C5层全相连。有10164个可训练参数。如同经典神经网络，F6层计算输入向量和权重向量之间的点积，再加上一个偏置。然后将其传递给sigmoid函数产生单元i的一个状态。</p><p>​      最后，输出层由欧式径向基函数（Euclidean Radial Basis Function）单元组成，每类一个单元，每个有84个输入。换句话说，每个输出RBF单元计算输入向量和参数向量之间的欧式距离。输入离参数向量越远，RBF输出的越大。一个RBF输出可以被理解为衡量输入模式和与RBF相关联类的一个模型的匹配程度的惩罚项。用概率术语来说，RBF输出可以被理解为F6层配置空间的高斯分布的负log-likelihood。给定一个输入模式，损失函数应能使得F6的配置与RBF参数向量（即模式的期望分类）足够接近。这些单元的参数是人工选取并保持固定的（至少初始时候如此）。这些参数向量的成分被设为-1或1。虽然这些参数可以以-1和1等概率的方式任选，或者构成一个纠错码，但是被设计成一个相应字符类的7*12大小（即84）的格式化图片。这种表示对识别单独的数字不是很有用，但是对识别可打印ASCII集中的字符串很有用。</p><p>​      使用这种分布编码而非更常用的“1 of N”编码用于产生输出的另一个原因是，当类别比较大的时候，非分布编码的效果比较差。原因是大多数时间非分布编码的输出必须为0。这使得用sigmoid单元很难实现。另一个原因是分类器不仅用于识别字母，也用于拒绝非字母。使用分布编码的RBF更适合该目标。因为与sigmoid不同，他们在输入空间的较好限制的区域内兴奋，而非典型模式更容易落到外边。</p><p>​        RBF参数向量起着F6层目标向量的角色。需要指出这些向量的成分是+1或-1，这正好在F6 sigmoid的范围内，因此可以防止sigmoid函数饱和。实际上，+1和-1是sigmoid函数的最大弯曲的点处。这使得F6单元运行在最大非线性范围内。必须避免sigmoid函数的饱和，因为这将会导致损失函数较慢的收敛和病态问题。</p><p><strong>5）训练过程</strong></p><p>​        神经网络用于模式识别的主流是有指导学习网络，无指导学习网络更多的是用于聚类分析。对于有指导的模式识别，由于任一样本的类别是已知的，样本在空间的分布不再是依据其自然分布倾向来划分，而是要根据同类样本在空间的分布及不同类样本之间的分离程度找一种适当的空间划分方法，或者找到一个分类边界，使得不同类样本分别位于不同的区域内。这就需要一个长时间且复杂的学习过程，不断调整用以划分样本空间的分类边界的位置，使尽可能少的样本被划分到非同类区域中。</p><p>​       卷积网络在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力。卷积网络执行的是有导师训练，所以其样本集是由形如：（输入向量，理想输出向量）的向量对构成的。所有这些向量对，都应该是来源于网络即将模拟的系统的实际“运行”结果。它们可以是从实际运行系统中采集来的。在开始训练前，所有的权都应该用一些不同的小随机数进行初始化。“小随机数”用来保证网络不会因权值过大而进入饱和状态，从而导致训练失败；“不同”用来保证网络可以正常地学习。实际上，如果用相同的数去初始化权矩阵，则网络无能力学习。</p><p>​       训练算法与传统的BP算法差不多。主要包括4步，这4步被分为两个阶段：</p><p><strong>第一阶段，向前传播阶段：</strong></p><p>a）从样本集中取一个样本(X,Yp)，将X输入网络；</p><p>b）计算相应的实际输出Op。</p><p>​      在此阶段，信息从输入层经过逐级的变换，传送到输出层。这个过程也是网络在完成训练后正常运行时执行的过程。在此过程中，网络执行的是计算（实际上就是输入与每层的权值矩阵相点乘，得到最后的输出结果）：</p><p>​          Op=Fn（…（F2（F1（XpW（1））W（2））…）W（n））</p><p><strong>第二阶段，向后传播阶段</strong></p><p>a）算实际输出Op与相应的理想输出Yp的差；</p><p>b）按极小化误差的方法反向传播调整权矩阵。</p><p><strong>6）卷积神经网络的优点</strong></p><p>​        卷积神经网络CNN主要用来识别位移、缩放及其他形式扭曲不变性的二维图形。由于CNN的特征检测层通过训练数据进行学习，所以在使用CNN时，避免了显式的特征抽取，而隐式地从训练数据中进行学习；再者由于同一特征映射面上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，特别是多维输入向量的图像可以直接输入网络这一特点避免了特征提取和分类过程中数据重建的复杂度。</p><p>​        流的分类方式几乎都是基于统计特征的，这就意味着在进行分辨前必须提取某些特征。然而，显式的特征提取并不容易，在一些应用问题中也并非总是可靠的。卷积神经网络，它避免了显式的特征取样，隐式地从训练数据中进行学习。这使得卷积神经网络明显有别于其他基于神经网络的分类器，通过结构重组和减少权值将特征提取功能融合进多层感知器。它可以直接处理灰度图片，能够直接用于处理基于图像的分类。</p><p>​       卷积网络较一般神经网络在图像处理方面有如下优点： a）输入图像和网络的拓扑结构能很好的吻合；b）特征提取和模式分类同时进行，并同时在训练中产生；c）权重共享可以减少网络的训练参数，使神经网络结构变得更简单，适应性更强。</p><p><strong>7）小结</strong></p><p>​       CNNs中这种层间联系和空域信息的紧密关系，使其适于图像处理和理解。而且，其在自动提取图像的显著特征方面还表现出了比较优的性能。在一些例子当中，Gabor滤波器已经被使用在一个初始化预处理的步骤中，以达到模拟人类视觉系统对视觉刺激的响应。在目前大部分的工作中，研究者将CNNs应用到了多种机器学习问题中，包括人脸识别，文档分析和语言检测等。为了达到寻找视频中帧与帧之间的相干性的目的，目前CNNs通过一个时间相干性去训练，但这个不是CNNs特有的。</p><p>​        呵呵，这部分讲得太啰嗦了，又没讲到点上。没办法了，先这样的，这样这个过程我还没有走过，所以自己水平有限啊，望各位明察。需要后面再改了，呵呵。</p><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p><strong>1）Deep learning总结</strong></p><p>​      深度学习是关于自动学习要建模的数据的潜在（隐含）分布的多层（复杂）表达的算法。换句话来说，深度学习算法自动的提取分类需要的低层次或者高层次特征。高层次特征，一是指该特征可以分级（层次）地依赖其他特征，例如：对于机器视觉，深度学习算法从原始图像去学习得到它的一个低层次表达，例如边缘检测器，小波滤波器等，然后在这些低层次表达的基础上再建立表达，例如这些低层次表达的线性或者非线性组合，然后重复这个过程，最后得到一个高层次的表达。</p><p>​       Deep learning能够得到更好地表示数据的feature，同时由于模型的层次、参数很多，capacity足够，因此，模型有能力表示大规模数据，所以对于图像、语音这种特征不明显（需要手工设计且很多没有直观物理含义）的问题，能够在大规模训练数据上取得更好的效果。此外，从模式识别特征和分类器的角度，deep learning框架将feature和分类器结合到一个框架中，用数据去学习feature，在使用中减少了手工设计feature的巨大工作量（这是目前工业界工程师付出努力最多的方面），因此，不仅仅效果可以更好，而且，使用起来也有很多方便之处，因此，是十分值得关注的一套框架，每个做ML的人都应该关注了解一下。</p><p>​       当然，deep learning本身也不是完美的，也不是解决世间任何ML问题的利器，不应该被放大到一个无所不能的程度。</p><p><strong>2）Deep learning未来</strong></p><p>​       深度学习目前仍有大量工作需要研究。目前的关注点还是从机器学习的领域借鉴一些可以在深度学习使用的方法，特别是降维领域。例如：目前一个工作就是稀疏编码，通过压缩感知理论对高维数据进行降维，使得非常少的元素的向量就可以精确的代表原来的高维信号。另一个例子就是半监督流行学习，通过测量训练样本的相似性，将高维数据的这种相似性投影到低维空间。另外一个比较鼓舞人心的方向就是evolutionary programming approaches（遗传编程方法），它可以通过最小化工程能量去进行概念性自适应学习和改变核心架构。</p><p>Deep learning还有很多核心的问题需要解决：</p><p>（1）对于一个特定的框架，对于多少维的输入它可以表现得较优（如果是图像，可能是上百万维）？</p><p>（2）对捕捉短时或者长时间的时间依赖，哪种架构才是有效的？</p><p>（3）如何对于一个给定的深度学习架构，融合多种感知的信息？</p><p>（4）有什么正确的机理可以去增强一个给定的深度学习架构，以改进其鲁棒性和对扭曲和数据丢失的不变性？</p><p>（5）模型方面是否有其他更为有效且有理论依据的深度模型学习算法？</p><p>​       探索新的特征提取模型是值得深入研究的内容。此外有效的可并行训练算法也是值得研究的一个方向。当前基于最小批处理的随机梯度优化算法很难在多计算机中进行并行训练。通常办法是利用图形处理单元加速学习过程。然而单个机器GPU对大规模数据识别或相似任务数据集并不适用。在深度学习应用拓展方面，如何合理充分利用深度学习在增强传统学习算法的性能仍是目前各领域的研究重点。</p><h2 id="参考文献和Deep-Learning学习资源（持续更新……）"><a href="#参考文献和Deep-Learning学习资源（持续更新……）" class="headerlink" title="参考文献和Deep Learning学习资源（持续更新……）"></a>参考文献和Deep Learning学习资源（持续更新……）</h2><p>​       先是机器学习领域大牛的微博：@余凯<em>西二旗民工；@老师木；@梁斌penny；@张栋</em>机器学习；@邓侃；@大数据皮东；@djvu9……</p><p>（1）Deep Learning</p><p><a href="http://deeplearning.net/" target="_blank" rel="noopener">http://deeplearning.net/</a></p><p>（2）Deep Learning Methods for Vision</p><p><a href="http://cs.nyu.edu/~fergus/tutorials/deep_learning_cvpr12/" target="_blank" rel="noopener">http://cs.nyu.edu/~fergus/tutorials/deep_learning_cvpr12/</a></p><p>（3）Neural Network for Recognition of Handwritten Digits[Project]</p><p><a href="http://www.codeproject.com/Articles/16650/Neural-Network-for-Recognition-of-Handwritten-Digi" target="_blank" rel="noopener">http://www.codeproject.com/Articles/16650/Neural-Network-for-Recognition-of-Handwritten-Digi</a></p><p>（4）Training a deep autoencoder or a classifier on MNIST digits</p><p><a href="http://www.cs.toronto.edu/~hinton/MatlabForSciencePaper.html" target="_blank" rel="noopener">http://www.cs.toronto.edu/~hinton/MatlabForSciencePaper.html</a></p><p>（5）Ersatz：deep neural networks in the cloud</p><p><a href="http://www.ersatz1.com/" target="_blank" rel="noopener">http://www.ersatz1.com/</a></p><p>（6）Deep Learning</p><p><a href="http://www.cs.nyu.edu/~yann/research/deep/" target="_blank" rel="noopener">http://www.cs.nyu.edu/~yann/research/deep/</a></p><p>（7）Invited talk “A Tutorial on Deep Learning” by Dr. Kai Yu (余凯)</p><p><a href="http://vipl.ict.ac.cn/News/academic-report-tutorial-deep-learning-dr-kai-yu" target="_blank" rel="noopener">http://vipl.ict.ac.cn/News/academic-report-tutorial-deep-learning-dr-kai-yu</a></p><p>（8）CNN - Convolutional neural network class</p><p><a href="http://www.mathworks.cn/matlabcentral/fileexchange/24291" target="_blank" rel="noopener">http://www.mathworks.cn/matlabcentral/fileexchange/24291</a></p><p>（9）Yann LeCun’s Publications</p><p><a href="http://yann.lecun.com/exdb/publis/index.html#lecun-98" target="_blank" rel="noopener">http://yann.lecun.com/exdb/publis/index.html#lecun-98</a></p><p>（10） LeNet-5, convolutional neural networks</p><p><a href="http://yann.lecun.com/exdb/lenet/index.html" target="_blank" rel="noopener">http://yann.lecun.com/exdb/lenet/index.html</a></p><p>（11） Deep Learning 大牛Geoffrey E. Hinton’s HomePage</p><p><a href="http://www.cs.toronto.edu/~hinton/" target="_blank" rel="noopener">http://www.cs.toronto.edu/~hinton/</a></p><p>（12）Sparse coding simulation software[Project]</p><p><a href="http://redwood.berkeley.edu/bruno/sparsenet/" target="_blank" rel="noopener">http://redwood.berkeley.edu/bruno/sparsenet/</a></p><p>（13）Andrew Ng’s homepage</p><p><a href="http://robotics.stanford.edu/~ang/" target="_blank" rel="noopener">http://robotics.stanford.edu/~ang/</a></p><p>（14）stanford deep learning tutorial</p><p><a href="http://deeplearning.stanford.edu/wiki/index.php/UFLDL_Tutorial" target="_blank" rel="noopener">http://deeplearning.stanford.edu/wiki/index.php/UFLDL_Tutorial</a></p><p>（15）「深度神经网络」（deep neural network）具体是怎样工作的</p><p><a href="http://www.zhihu.com/question/19833708?group_id=15019075#1657279" target="_blank" rel="noopener">http://www.zhihu.com/question/19833708?group_id=15019075#1657279</a></p><p>（16）A shallow understanding on deep learning</p><p><a href="http://blog.sina.com.cn/s/blog_6ae183910101dw2z.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6ae183910101dw2z.html</a></p><p>（17）Bengio’s Learning Deep Architectures for AI</p><p> <a href="http://www.iro.umontreal.ca/~bengioy/papers/ftml_book.pdf" target="_blank" rel="noopener">http://www.iro.umontreal.ca/~bengioy/papers/ftml_book.pdf</a></p><p>（18）andrew ng’s talk video:</p><p><a href="http://techtalks.tv/talks/machine-learning-and-ai-via-brain-simulations/57862/" target="_blank" rel="noopener">http://techtalks.tv/talks/machine-learning-and-ai-via-brain-simulations/57862/</a></p><p>（19）cvpr 2012 tutorial：</p><p><a href="http://cs.nyu.edu/~fergus/tutorials/deep_learning_cvpr12/tutorial_p2_nnets_ranzato_short.pdf" target="_blank" rel="noopener">http://cs.nyu.edu/~fergus/tutorials/deep_learning_cvpr12/tutorial_p2_nnets_ranzato_short.pdf</a></p><p>（20）Andrew ng清华报告听后感</p><p><a href="http://blog.sina.com.cn/s/blog_593af2a70101bqyo.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_593af2a70101bqyo.html</a></p><p>（21）Kai Yu：CVPR12 Tutorial on Deep Learning Sparse Coding</p><p>（22）Honglak Lee：Deep Learning Methods for Vision</p><p>（23）Andrew Ng ：Machine Learning and AI via Brain simulations</p><p>（24）Deep Learning 【2,3】</p><p><a href="http://blog.sina.com.cn/s/blog_46d0a3930101gs5h.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_46d0a3930101gs5h.html</a></p><p>（25）deep learning这件小事……</p><p><a href="http://blog.sina.com.cn/s/blog_67fcf49e0101etab.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_67fcf49e0101etab.html</a></p><p>（26）Yoshua Bengio, U. Montreal：Learning Deep Architectures</p><p>（27）Kai Yu：A Tutorial on Deep Learning</p><p>（28）Marc’Aurelio Ranzato：NEURAL NETS FOR VISION</p><p>（29）Unsupervised feature learning and deep learning</p><p><a href="http://blog.csdn.net/abcjennifer/article/details/7804962" target="_blank" rel="noopener">http://blog.csdn.net/abcjennifer/article/details/7804962</a></p><p>（30）机器学习前沿热点–Deep Learning</p><p><a href="http://elevencitys.com/?p=1854" target="_blank" rel="noopener">http://elevencitys.com/?p=1854</a></p><p>（31）机器学习——深度学习(Deep Learning)</p><p><a href="http://blog.csdn.net/abcjennifer/article/details/7826917" target="_blank" rel="noopener">http://blog.csdn.net/abcjennifer/article/details/7826917</a></p><p>（32）卷积神经网络</p><p><a href="http://wenku.baidu.com/view/cd16fb8302d276a200292e22.html" target="_blank" rel="noopener">http://wenku.baidu.com/view/cd16fb8302d276a200292e22.html</a></p><p>（33）浅谈Deep Learning的基本思想和方法</p><p><a href="http://blog.csdn.net/xianlingmao/article/details/8478562" target="_blank" rel="noopener">http://blog.csdn.net/xianlingmao/article/details/8478562</a></p><p>（34）深度神经网络</p><p><a href="http://blog.csdn.net/txdb/article/details/6766373" target="_blank" rel="noopener">http://blog.csdn.net/txdb/article/details/6766373</a></p><p>（35）Google的猫脸识别:人工智能的新突破</p><p><a href="http://www.36kr.com/p/122132.html" target="_blank" rel="noopener">http://www.36kr.com/p/122132.html</a></p><p>（36）余凯，深度学习-机器学习的新浪潮，Technical News程序天下事</p><p><a href="http://blog.csdn.net/datoubo/article/details/8577366" target="_blank" rel="noopener">http://blog.csdn.net/datoubo/article/details/8577366</a></p><p>（37）Geoffrey Hinton：UCLTutorial on: Deep Belief Nets</p><p>（38）Learning Deep Boltzmann Machines</p><p><a href="http://web.mit.edu/~rsalakhu/www/DBM.html" target="_blank" rel="noopener">http://web.mit.edu/~rsalakhu/www/DBM.html</a></p><p>（39）Efficient Sparse Coding Algorithm</p><p><a href="http://blog.sina.com.cn/s/blog_62af19190100gux1.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_62af19190100gux1.html</a></p><p>（40）Itamar Arel, Derek C. Rose, and Thomas P. Karnowski： Deep Machine Learning—A New Frontier in Artificial Intelligence Research</p><p>（41）Francis Quintal Lauzon：An introduction to deep learning</p><p>（42）Tutorial on Deep Learning and Applications</p><p>（43）Boltzmann神经网络模型与学习算法</p><p><a href="http://wenku.baidu.com/view/490dcf748e9951e79b892785.html" target="_blank" rel="noopener">http://wenku.baidu.com/view/490dcf748e9951e79b892785.html</a></p><p>（44）Deep Learning 和 Knowledge Graph 引爆大数据革命</p><p><a href="http://blog.sina.com.cn/s/blog_46d0a3930101fswl.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_46d0a3930101fswl.html</a></p>]]></content>
    
    <summary type="html">
    
      CNN-卷积神经网络是目前图像识别方向比较重要的一个神经算法，使用它比传统的神经网络识别图片效果更佳。
    
    </summary>
    
      <category term="天天进步一点点AI篇" scheme="http://yushiyang.top/categories/%E5%A4%A9%E5%A4%A9%E8%BF%9B%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9AI%E7%AF%87/"/>
    
    
      <category term="python" scheme="http://yushiyang.top/tags/python/"/>
    
      <category term="AI" scheme="http://yushiyang.top/tags/AI/"/>
    
      <category term="数学" scheme="http://yushiyang.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="算法" scheme="http://yushiyang.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="转载" scheme="http://yushiyang.top/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>天天进步一点点AI篇--k-means聚类算法</title>
    <link href="http://yushiyang.top/2017/10/27/StudyEveryday-k-means/"/>
    <id>http://yushiyang.top/2017/10/27/StudyEveryday-k-means/</id>
    <published>2017-10-27T01:45:10.000Z</published>
    <updated>2017-10-27T06:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>目前深度学习主要分为两大类，一个是监督学习，一个为非监督学习，监督学习（当然还有什么半监督学习等等，在这里不做讨论）</p><p><strong>监督学习</strong>：输入数据有被称为训练数据，它们有已知的标签或者结果，模型的参数确定需要通过一个训练的过程，在这个过程中模型将会要求作出预测，当预测不准时，则需要作出修改</p><p><strong>非监督学习</strong>：输入数据不带标签或者没有一个已知的结果，通过推测输入数据中存在的结果来建立模型，这类算法主要集中体现在关联规则学习，聚类等等，聚类的基本入门算法就是k-means聚类算法</p><p><strong>k-means聚类算法</strong>：算法简单的思想如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">选择k个点作为初始质点（即我们要取得的分类）</span><br><span class="line">repeat</span><br><span class="line">      将每个点指派到最近的质点，形成k个簇</span><br><span class="line">      重新计算每个簇的质心</span><br><span class="line">until</span><br><span class="line">      簇不发生变化或达到最大迭代数</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="/img/k-means-one.jpg" alt="k-means-one"></p><ol><li>选取初始质点k（图1）</li><li>计算距离，把距离相近的当做一个簇，有几个k值就能形成几个簇（图2）</li><li>形成簇后计算得出簇的中心点生成新的值（图中灰点），继续聚类，形成新的簇（图3）</li><li>直到值不在变换或者迭代数达到我们规定的值，则结束，聚类完成</li></ol><h2 id="实现k-means"><a href="#实现k-means" class="headerlink" title="实现k-means"></a>实现k-means</h2><h3 id="如何选取k"><a href="#如何选取k" class="headerlink" title="如何选取k"></a>如何选取k</h3><p>k-means算法首先选择k个初始质心，其中k是用户指定的参数，即所期望的簇的个数，但是在大多数情况下我们都是无法预测k的情况的，所以我们需要一些标准或方法来帮助我们获取更好的k。</p><p>这里有几种方法摘至他人的博客</p><ol><li>与层次聚类结合</li></ol><p>经常会产生较好的聚类结果的一个有趣策略是，首先采用层次凝聚算法决定结果簇的数目，并找到一个初始聚类，然后用迭代重定位来改进该聚类。</p><ol><li>稳定性方法</li></ol><p>稳定性方法对一个数据集进行2次重采样产生2个数据子集，再用相同的聚类算法对2个数据子集进行聚类，产生2个具有k个聚类的聚类结果，计算2个聚类结果的相似度的分布情况。2个聚类结果具有高的相似度说明k个聚类反映了稳定的聚类结构，其相似度可以用来估计聚类个数。采用次方法试探多个k，找到合适的k值。</p><ol><li>系统演化方法</li></ol><p>系统演化方法将一个数据集视为伪热力学系统，当数据集被划分为K个聚类时称系统处于状态K。系统由初始状态K=1出发，经过分裂过程和合并过程，系统将演化到它的稳定平衡状态Ki，其所对应的聚类结构决定了最优类数Ki。系统演化方法能提供关于所有聚类之间的相对边界距离或可分程度，它适用于明显分离的聚类结构和轻微重叠的聚类结构。</p><ol><li>使用canpopy算法进行初始划分</li></ol><p>基于Canopy Method的聚类算法将聚类过程分为两个阶段</p><p>Stage1、聚类最耗费计算的地方是计算对象相似性的时候，Canopy Method在第一阶段选择简单、计算代价较低的方法计算对象相似性，将相似的对象放在一个子集中，这个子集被叫做Canopy ，通过一系列计算得到若干Canopy，Canopy之间可以是重叠的，但不会存在某个对象不属于任何Canopy的情况，可以把这一阶段看做数据预处理；</p><p>Stage2、在各个Canopy 内使用传统的聚类方法(如K-means)，不属于同一Canopy 的对象之间不进行相似性计算。</p><p>从这个方法起码可以看出两点好处：首先，Canopy 不要太大且Canopy 之间重叠的不要太多的话会大大减少后续需要计算相似性的对象的个数；其次，类似于K-means这样的聚类方法是需要人为指出K的值的，通过Stage1得到的Canopy 个数完全可以作为这个K值，一定程度上减少了选择K的盲目性。</p><h3 id="如何选取初始值"><a href="#如何选取初始值" class="headerlink" title="如何选取初始值"></a>如何选取初始值</h3><p><strong>思想</strong>,初始的聚类中心之间相互距离尽可能的远。</p><ol><li><strong>方法一：</strong>kmeans++</li></ol><ul><li>从输入的数据点集合中随机选择一个点作为第一个聚类中心</li><li>对于数据集中的每一个点x，计算它与最近聚类中心(指已选择的聚类中心)的距离D(x)</li><li>选择一个新的数据点作为新的聚类中心，选择的原则是：D(x)较大的点，被选取作为聚类中心的概率较大</li><li>重复2和3直到k个聚类中心被选出来</li><li>利用这k个初始的聚类中心来运行标准的k-means算法</li></ul><p>从上面的算法描述上可以看到，算法的关键是第3步，如何将D(x)反映到点被选择的概率上，一种算法如下：</p><ul><li>先从我们的数据库随机挑个随机点当“种子点”</li><li>对于每个点，我们都计算其和最近的一个“种子点”的距离D(x)并保存在一个数组里，然后把这些距离加起来得到Sum(D(x))。</li><li>然后，再取一个随机值，用权重的方式来取计算下一个“种子点”。这个算法的实现是，先取一个能落在Sum(D(x))中的随机值Random，然后用Random -= D(x)，直到其&lt;=0，此时的点就是下一个“种子点”。</li><li>重复2和3直到k个聚类中心被选出来</li><li>利用这k个初始的聚类中心来运行标准的k-means算法</li></ul><ol><li><strong>方法二：</strong>选用层次聚类或Canopy算法进行初始聚类，然后从k个类别中分别随机选取k个点，来作为kmeans的初始聚类中心点</li></ol><h3 id="距离算法及其何时停止"><a href="#距离算法及其何时停止" class="headerlink" title="距离算法及其何时停止"></a>距离算法及其何时停止</h3><p>样本和中心点两点间的距离直接使用<strong>欧几里得距离</strong>距离求得即可。</p><p><strong>求点群中心的算法</strong></p><p>这里有几个公司简单提一下</p><ul><li><strong>Minkowski Distance公式——</strong>λ可以随意取值，可以是负数，也可以是正数，或是无穷大</li></ul><p><img src="/img/k-means-two.gif" alt="k-means-two"></p><ul><li><strong>Euclidean Distance公式</strong>——也就是第一个公式λ=2的情况</li></ul><p><img src="/img/k-means-three.gif" alt="k-means-three"></p><ul><li><strong>CityBlock Distance公式</strong>——也就是第一个公式λ=1的情况</li></ul><p><img src="/img/k-means-four.gif" alt="k-means-four"></p><p>什么时候结束？一般情况下都是所求的群中心都不在变化时迭代结束</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>k-means存在缺点：</p><ul><li>k-means是局部最优的，容易受到初始质心的影响；</li><li>同时，k值的选取也会直接影响聚类结果，最优聚类的k值应与样本数据本身的结构信息相吻合，而这种结构信息是很难去掌握，因此选取最优k值是非常困难的。</li></ul><p>最后给一个挺好的算法的幻灯片：<a href="http://www.cs.cmu.edu/~guestrin/Class/10701-S07/Slides/clustering.pdf" target="_blank" rel="noopener">http://www.cs.cmu.edu/~guestrin/Class/10701-S07/Slides/clustering.pdf</a></p>]]></content>
    
    <summary type="html">
    
      k-means聚类算法作为非监督学习的入门算法之一，简单易用，有时会显示出强大的效果，但有时聚类出的结果却令人失望，很不理想。
    
    </summary>
    
      <category term="天天进步一点点AI篇" scheme="http://yushiyang.top/categories/%E5%A4%A9%E5%A4%A9%E8%BF%9B%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9AI%E7%AF%87/"/>
    
    
      <category term="python" scheme="http://yushiyang.top/tags/python/"/>
    
      <category term="AI" scheme="http://yushiyang.top/tags/AI/"/>
    
      <category term="数学" scheme="http://yushiyang.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="算法" scheme="http://yushiyang.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="原创" scheme="http://yushiyang.top/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>天天进步一点点AI篇--最大似然估计(MLE)</title>
    <link href="http://yushiyang.top/2017/10/26/StudyEveryday-MLE/"/>
    <id>http://yushiyang.top/2017/10/26/StudyEveryday-MLE/</id>
    <published>2017-10-26T02:34:49.000Z</published>
    <updated>2017-10-27T03:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h2 id="什么是最大似然估计"><a href="#什么是最大似然估计" class="headerlink" title="什么是最大似然估计"></a>什么是最大似然估计</h2><p>简单一点就是</p><blockquote><p>利用已知的样本结果，反推最有可能（概率最大）导致这样结果的参数值</p></blockquote><p>最大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”，而我们做的就是要寻找这样的参数值，使之在这个模型下能更好的预测结果。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>一般求解的过程：</p><ol><li>写出似然函数</li><li>对似然函数取对数，并整理</li><li>求导数</li><li>解似然方程</li></ol><p><strong>最大似然估计只考虑某个模型能产生某个给定的观察序列的概率，而不考虑给定的函数本身的概率（即函数本身的好坏和最大似然估计无关）</strong></p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p><strong>我们所估计的模型参数，要使得产生这个给定样本的可能性最大</strong>。在最大似然估计中，我们试图在给定模型的情况下，找到最佳的参数，使得这组样本出现的可能性最大。</p><p>在机器学习的异常检测中，根据模型（通过学习得来的）计算一个数据点出现的概率，如果这个概率小于某个我们事先设定的值，就把它判为异常。我们基于的是一个小事件的思想：如果一件可能性极小的事情竟然发生了，那么就极有可能是异常。举个例子，我和习大大会成为好朋友的概率机会为0，要是哪天我们一起去撸串那肯定就是异常了。</p><h2 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h2><p>在<a href="https://baike.baidu.com/item/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%AD%A6" target="_blank" rel="noopener">数理统计学</a>中，<strong>似然函数</strong>是一种关于<a href="https://baike.baidu.com/item/%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">统计模型</a>中的<a href="https://baike.baidu.com/item/%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">参数</a>的<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">函数</a>，表示模型参数中的<strong>似然性</strong>。</p><p>给定输出x时，关于参数θ的似然函数L(θ|x)（在数值上）等于给定参数θ后变量X的概率：</p><p>$$L(\Theta |x) = P(X=x|\Theta)$$</p><p>似然函数在<a href="https://baike.baidu.com/item/%E6%8E%A8%E6%96%AD%E7%BB%9F%E8%AE%A1%E5%AD%A6" target="_blank" rel="noopener">推断统计学</a>（Statistical inference）中扮演重要角色，如在<a href="https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1" target="_blank" rel="noopener">最大似然估计</a>和费雪信息之中的应用等等。“似然性”与“或然性”或“<a href="https://baike.baidu.com/item/%E6%A6%82%E7%8E%87" target="_blank" rel="noopener">概率</a>”意思相近，都是指某种事件发生的可能性，但是在<a href="https://baike.baidu.com/item/%E7%BB%9F%E8%AE%A1%E5%AD%A6" target="_blank" rel="noopener">统计学</a>中，“似然性”和“或然性”或“概率”又有明确的区分。<a href="https://baike.baidu.com/item/%E6%A6%82%E7%8E%87" target="_blank" rel="noopener">概率</a>用于在已知一些参数的情况下，预测接下来的观测所得到的结果，而似然性则是用于在已知某些观测所得到的结果时，对有关事物的性质的参数进行估计。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>举个别人博客中的例子，假如有一个罐子，里面有黑白两种颜色的球，数目多少不知，两种颜色的比例也不知。我 们想知道罐中白球和黑球的比例，但我们不能把罐中的球全部拿出来数。现在我们可以每次任意从已经摇匀的罐中拿一个球出来，记录球的颜色，然后把拿出来的球 再放回罐中。这个过程可以重复，我们可以用记录的球的颜色来估计罐中黑白球的比例。假如在前面的一百次重复记录中，有七十次是白球，请问罐中白球所占的比例最有可能是多少？很多人马上就有答案了：70%。而其后的理论支撑是什么呢？</p><p>我们假设罐中白球的比例是p，那么黑球的比例就是1-p。因为每抽一个球出来，在记录颜色之后，我们把抽出的球放回了罐中并摇匀，所以每次抽出来的球的颜 色服从同一独立分布。这里我们把一次抽出来球的颜色称为一次抽样。题目中在一百次抽样中，七十次是白球的概率是P(Data | M)，这里Data是所有的数据，M是所给出的模型，表示每次抽出来的球是白色的概率为p。如果第一抽样的结果记为$x_1$，第二抽样的结果记为$x_2…$ 那么$Data = (x_1,x_2,…,x_100)$。这样就会有：</p><p>$P(Data | M)$</p><p>$= P(x_1,x_2,…,x_100|M)$</p><p>$= P(x_1|M)P(x_2|M)…P(x_100|M)$</p><p>$= p^{70}(1-p)^{30}$</p><p>那么p在取什么值的时候，P(Data |M)的值最大呢？将$p^{70}(1-p)^{30}$对p求导，并其等于零。</p><p>　　　　$70p^{69}(1-p)^{30}-p^{70}*30(1-p)^{29}=0$。</p><p>　　　　解方程可以得到p=0.7。</p><p>在边界点p=0,1，P(Data|M)=0。所以当p=0.7时，P(Data|M)的值最大。这和我们常识中按抽样中的比例来计算的结果是一样的。</p>]]></content>
    
    <summary type="html">
    
      最大似然估计和最小二乘法有点小关系，前者是已有模型求参数，而后者是寻找拟合最好的模型
    
    </summary>
    
      <category term="天天进步一点点AI篇" scheme="http://yushiyang.top/categories/%E5%A4%A9%E5%A4%A9%E8%BF%9B%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9AI%E7%AF%87/"/>
    
    
      <category term="python" scheme="http://yushiyang.top/tags/python/"/>
    
      <category term="AI" scheme="http://yushiyang.top/tags/AI/"/>
    
      <category term="数学" scheme="http://yushiyang.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="算法" scheme="http://yushiyang.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="原创" scheme="http://yushiyang.top/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>天天进步一点点AI篇--最小二乘法</title>
    <link href="http://yushiyang.top/2017/10/20/StudyEveryday-LeastSquareMethod/"/>
    <id>http://yushiyang.top/2017/10/20/StudyEveryday-LeastSquareMethod/</id>
    <published>2017-10-20T06:50:56.000Z</published>
    <updated>2017-10-24T03:36:52.000Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h2 id="最小二乘法历史简介"><a href="#最小二乘法历史简介" class="headerlink" title="最小二乘法历史简介"></a>最小二乘法历史简介</h2><p>1801年，意大利天文学家朱赛普·皮亚齐发现了第一颗小行星谷神星。经过40天的跟踪观测后，由于谷神星运行至太阳背后，使得皮亚齐失去了谷神星的位置。随后全世界的科学家利用皮亚齐的观测数据开始寻找谷神星，但是根据大多数人计算的结果来寻找谷神星都没有结果。时年24岁的高斯也计算了谷神星的轨道。奥地利天文学家海因里希·奥尔伯斯根据高斯计算出来的轨道重新发现了谷神星。</p><p>高斯使用的最小二乘法的方法发表于1809年他的著作《天体运动论》中。</p><p>法国科学家勒让德于1806年独立发现“最小二乘法”。但因不为时人所知而默默无闻。</p><p>勒让德曾与高斯为谁最早创立最小二乘法原理发生争执。</p><p>1829年，高斯提供了最小二乘法的优化效果强于其他方法的证明，因此被称为<a href="http://wiki.mbalib.com/w/index.php?title=%E9%AB%98%E6%96%AF-%E8%8E%AB%E5%8D%A1%E5%A4%AB%E5%AE%9A%E7%90%86&amp;action=edit" target="_blank" rel="noopener">高斯-莫卡夫定理</a>。</p><h2 id="什么是最小二乘法"><a href="#什么是最小二乘法" class="headerlink" title="什么是最小二乘法"></a>什么是最小二乘法</h2><blockquote><p>The method of <strong>least squares</strong> is a standard approach in <a href="https://en.wikipedia.org/wiki/Regression_analysis" target="_blank" rel="noopener">regression analysis</a> to the approximate solution of <a href="https://en.wikipedia.org/wiki/Overdetermined_system" target="_blank" rel="noopener">overdetermined systems</a>, i.e., sets of equations in which there are more equations than unknowns. “Least squares” means that the overall solution minimizes the sum of the squares of the residuals made in the results of every single equation.</p><p>The most important application is in <a href="https://en.wikipedia.org/wiki/Curve_fitting" target="_blank" rel="noopener">data fitting</a>. The best fit in the least-squares sense minimizes <em>the sum of squared residuals</em> (a residual being: the difference between an observed value, and the fitted value provided by a model). </p></blockquote><p>以上摘至维基百科</p><p>翻译过来简单点说就是：</p><ul><li>最小二乘法是一种标准的方法，回归分析等用的比较多，指每一方程结果中残差的平方和的整体解最小化</li><li>最重要的应用是数据拟合。最小二乘法中的最佳拟合将残差平方和（残差为：观测值之间的差值和模型提供的拟合值）最小化。</li></ul><h2 id="怎么理解"><a href="#怎么理解" class="headerlink" title="怎么理解"></a>怎么理解</h2><p>假设这有一系列成对的数据: $(x_1,y_1,x_2,y_2,…,x_m,y_m)$,对于平面中的这m个点，可以使用无数条曲线来拟合。要求样本回归函数尽可能好地拟合这组值。</p><p>最佳拟合曲线的标准可以确定为：使总的拟合误差（总残差）达到最小，有以下的三个标准可以选择：</p><ol><li>用“残差和最小”确定直线位置是一个途径，但计算发现“残差和”存在相互抵消的问题。</li><li>用“残差绝对值和最小”确定直线位置也是一个途径，但你会发现绝对值的计算比较麻烦。</li><li>最小二乘法的原则是以“残差平方和最小”确定直线位置，用最小二乘法除了计算比较方便外，得到的估计量还具有优良特性，这种方法对异常值非常敏感。</li></ol><p>最常用的是普通最小二乘法，所选择的回归模型应该使所有的观察值的残差平方和达到最小。（Q为残差和平方和）—即采用平方损失函数</p><p>假设函数$$H(x,y)=a_0+a_1x+…+a_nx$$</p><p>样本回归模型：$$Y_i=a_0+a_1x_i+e_i \Rightarrow e_i=Y_i-a_0-a_1x_i$$   </p><p>其中$e_i$为样本$(x_i,Y_i)$的误差。</p><p>平方损失函数为：</p><p>$Q = \sum_{i=0}^n{e_i^2} $ </p><p>$\Rightarrow \sum_{i=0}^n(Y_i(实际测量值)-Y_i(公式计算值))^2  $ </p><p>$\Rightarrow \sum_{i=0}^n(Y_i(实际测量值)-a_0-a_1x_i)^2$ </p><p>接下来我们要做的就是得到Q的最小值，求此时的$a_0,a_1$,把$a_0,a_1$作为变量，看做是Q的函数，就变成了一个求极值的问题，通过求偏导可得：</p><p>$\frac{\alpha Q}{\alpha a_0} = $         (对$a_0$的偏导)</p><p>$2\sum_{i=0}^n{(Y_i(实际测量值)-a_0-a_1x_i)(-1)} = 0$ </p><p>$\frac{\alpha Q}{\alpha a_1} =$         (对$a_1$的偏导)</p><p>$2 \sum_{i=0}^n{(Y_i(实际测量值)-a_0-a_1x_i)(-x_i)} = 0$</p><p>这就是最小二乘法的基本解法，求观测值之间的差值和模型提供的拟合值。</p>]]></content>
    
    <summary type="html">
    
      最小二乘法是一种有着悠久历史，但是非常重要的算法，直到今日，仍然是入门机器学习的基本算法，从求解线性透视图中的消失点，m元n次函数的拟合，包括后来的神经网络，其思想都是最小二乘法。
    
    </summary>
    
      <category term="天天进步一点点AI篇" scheme="http://yushiyang.top/categories/%E5%A4%A9%E5%A4%A9%E8%BF%9B%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9AI%E7%AF%87/"/>
    
    
      <category term="python" scheme="http://yushiyang.top/tags/python/"/>
    
      <category term="AI" scheme="http://yushiyang.top/tags/AI/"/>
    
      <category term="数学" scheme="http://yushiyang.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="算法" scheme="http://yushiyang.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="原创" scheme="http://yushiyang.top/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>天天进步一点点AI篇</title>
    <link href="http://yushiyang.top/2017/10/20/StudyEveryday/"/>
    <id>http://yushiyang.top/2017/10/20/StudyEveryday/</id>
    <published>2017-10-20T06:12:26.000Z</published>
    <updated>2017-10-20T06:48:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>听说，人工智能编程已经超越人类工程师了！！！</p><blockquote><p><em>近日，据外媒TNW报道，Google AutoML系统居然自己写了一串机器学习代码，其效率竟然超过了专业的研发工程师。这让我们人类的优越感何存？</em></p></blockquote><p>瑟瑟发抖的我还是慢慢的看完了那篇文章….</p><p>的确，现在人工智能的发展日新月异，我甚至觉得这是如同工业革命那种对世界产生巨变的真正意义上的解放人类的事件，要是真正达到人工那种智能甚至超过人类，那对我们的生活将是一个巨变！</p><p>也有不少人可能会有些担忧，要是什么都能让人工智能解决，那我们人类将有多少人失业等等，人工智能会不会摆脱人类的控制，甚至反向控制人类等许多对人类的质疑，我个人觉得，至少到目前为止，和不久的将来，人工智能带来的利远远大于弊。</p><p>真的无法想象，要是AI真的达到人类的预想，那该是一件多么<strong>NB</strong>的事情，你以前只能在大屏幕中看见的事情变成你生活中一件普通的不能再普通的事情，那该是多么充满诱惑，或许这就是为什么我想要学习这方面知识的原因吧，也许，到最后可能学不出什么名堂来，但我依旧想尝试一下。</p><p>接下来我会在学习中慢慢写一点东西，算是学习笔记吧，也方便过段时间回来查看，要是有什么不对的地方也欢迎指出(要是有人不耐其烦的看下去的话)。</p>]]></content>
    
    <summary type="html">
    
      随着人工智能的持续走热，python在众多语言中脱颖而出，接下来我也将投身这个大潮当中，学习学习，看看它究竟有何魅力！
    
    </summary>
    
      <category term="天天进步一点点AI篇" scheme="http://yushiyang.top/categories/%E5%A4%A9%E5%A4%A9%E8%BF%9B%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9AI%E7%AF%87/"/>
    
    
      <category term="python" scheme="http://yushiyang.top/tags/python/"/>
    
      <category term="AI" scheme="http://yushiyang.top/tags/AI/"/>
    
      <category term="数学" scheme="http://yushiyang.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="算法" scheme="http://yushiyang.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="原创" scheme="http://yushiyang.top/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>如果看了此文你还不懂傅里叶变换，那就过来掐死我吧【完整版】</title>
    <link href="http://yushiyang.top/2017/10/18/fuyeli/"/>
    <id>http://yushiyang.top/2017/10/18/fuyeli/</id>
    <published>2017-10-18T09:59:35.000Z</published>
    <updated>2017-10-18T10:09:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章出处-<a href="https://zhuanlan.zhihu.com/wille/19763358" target="_blank" rel="noopener">傅里叶变换</a></p><p>作 者：韩 昊</p><p>知 乎：Heinrich</p><p>微 博：@花生油工人</p><p>知乎专栏：与时间无关的故事</p><p>谨以此文献给大连海事大学的吴楠老师，柳晓鸣老师，王新年老师以及张晶泊老师。</p><p>我保证这篇文章和你以前看过的所有文章都不同，这是12年还在果壳的时候写的，但是当时没有来得及写完就出国了……于是拖了两年，嗯，我是拖延症患者……</p><p>这篇文章的核心思想就是：</p><p>我保证这篇文章和你以前看过的所有文章都不同，这是 2012 年还在果壳的时候写的，但是当时没有来得及写完就出国了……于是拖了两年，嗯，我是拖延症患者……</p><p>这篇文章的核心思想就是：</p><h2 id="要让读者在不看任何数学公式的情况下理解傅里叶分析。"><a href="#要让读者在不看任何数学公式的情况下理解傅里叶分析。" class="headerlink" title="要让读者在不看任何数学公式的情况下理解傅里叶分析。"></a>要让读者在不看任何数学公式的情况下理解傅里叶分析。</h2><p>傅里叶分析不仅仅是一个数学工具，更是一种可以彻底颠覆一个人以前世界观的思维模式。但不幸的是，傅里叶分析的公式看起来太复杂了，所以很多大一新生上来就懵圈并从此对它深恶痛绝。老实说，这么有意思的东西居然成了大学里的杀手课程，不得不归咎于编教材的人实在是太严肃了。（您把教材写得好玩一点会死吗？会死吗？）所以我一直想写一个有意思的文章来解释傅里叶分析，有可能的话高中生都能看懂的那种。所以，不管读到这里的您从事何种工作，我保证您都能看懂，并且一定将体会到通过傅里叶分析看到世界另一个样子时的快感。至于对于已经有一定基础的朋友，也希望不要看到会的地方就急忙往后翻，仔细读一定会有新的发现。</p><p>————以上是定场诗————</p><p>下面进入正题：</p><p>抱歉，还是要啰嗦一句：其实学习本来就不是易事，我写这篇文章的初衷也是希望大家学习起来更加轻松，充满乐趣。但是千万！千万不要把这篇文章收藏起来，或是存下地址，心里想着：以后有时间再看。这样的例子太多了，也许几年后你都没有再打开这个页面。无论如何，耐下心，读下去。这篇文章要比读课本要轻松、开心得多……</p><h2 id="什么是频域"><a href="#什么是频域" class="headerlink" title="什么是频域"></a>什么是频域</h2><p>从我们出生，我们看到的世界都以时间贯穿，股票的走势、人的身高、汽车的轨迹都会随着时间发生改变。这种以时间作为参照来观察动态世界的方法我们称其为时域分析。而我们也想当然的认为，世间万物都在随着时间不停的改变，并且永远不会静止下来。但如果我告诉你，用另一种方法来观察世界的话，你会发现<strong>世界是永恒不变的</strong>，你会不会觉得我疯了？我没有疯，这个静止的世界就叫做频域。</p><p><strong>先举一个公式上并非很恰当，但意义上再贴切不过的例子：</strong></p><p>在你的理解中，一段音乐是什么呢？</p><p><img src="http://ww3.sinaimg.cn/mw690/7cc829d3gw1eh5v4r7dlkj20go05mwff.jpg" alt="img"></p><p>这是我们对音乐最普遍的理解，一个随着时间变化的震动。但我相信对于乐器小能手们来说，音乐更直观的理解是这样的：</p><p><img src="http://ww2.sinaimg.cn/mw690/7cc829d3gw1eh5v4w5m0xj20go05nwff.jpg" alt="img"><br>好的！下课，同学们再见。</p><p>是的，其实这一段写到这里已经可以结束了。上图是音乐在时域的样子，而下图则是音乐在频域的样子。所以频域这一概念对大家都从不陌生，只是从来没意识到而已。</p><p>现在我们可以回过头来重新看看一开始那句痴人说梦般的话：世界是永恒的。</p><p>将以上两图简化：</p><p>时域：</p><p><img src="http://ww1.sinaimg.cn/mw690/7cc829d3gw1eh5v4xmosuj20go096t9l.jpg" alt="img"><br>频域：</p><p><img src="http://ww3.sinaimg.cn/mw690/7cc829d3gw1egu4n43a2gj203t05jq2r.jpg" alt="img"></p><p>在时域，我们观察到钢琴的琴弦一会上一会下的摆动，就如同一支股票的走势；而在频域，只有那一个永恒的音符。</p><p>所以</p><h2 id="你眼中看似落叶纷飞变化无常的世界，实际只是躺在上帝怀中一份早已谱好的乐章。"><a href="#你眼中看似落叶纷飞变化无常的世界，实际只是躺在上帝怀中一份早已谱好的乐章。" class="headerlink" title="你眼中看似落叶纷飞变化无常的世界，实际只是躺在上帝怀中一份早已谱好的乐章。"></a>你眼中看似落叶纷飞变化无常的世界，实际只是躺在上帝怀中一份早已谱好的乐章。</h2><p>抱歉，这不是一句鸡汤文，而是黑板上确凿的公式：傅里叶同学告诉我们，任何周期函数，都可以看作是不同振幅，不同相位正弦波的叠加。在第一个例子里我们可以理解为，利用对不同琴键不同力度，不同时间点的敲击，可以组合出任何一首乐曲。</p><p>而贯穿时域与频域的方法之一，就是传中说的傅里叶分析。傅里叶分析可分为傅里叶级数（Fourier Serie）和傅里叶变换(Fourier Transformation)，我们从简单的开始谈起。</p><h2 id="傅里叶级数-Fourier-Series-的频谱"><a href="#傅里叶级数-Fourier-Series-的频谱" class="headerlink" title="傅里叶级数(Fourier Series)的频谱"></a>傅里叶级数(Fourier Series)的频谱</h2><p>还是举个栗子并且有图有真相才好理解。</p><p>如果我说我能用前面说的正弦曲线波叠加出一个带 90 度角的矩形波来，你会相信吗？你不会，就像当年的我一样。但是看看下图：</p><p><img src="http://ww4.sinaimg.cn/mw690/7cc829d3gw1eh5v4yfzcsj20go0cujt7.jpg" alt="img"></p><p>第一幅图是一个郁闷的正弦波 cos（x）</p><p>第二幅图是 2 个卖萌的正弦波的叠加 cos (x) +a.cos (3x)</p><p>第三幅图是 4 个发春的正弦波的叠加</p><p>第四幅图是 10 个便秘的正弦波的叠加</p><p>随着正弦波数量逐渐的增长，他们最终会叠加成一个标准的矩形，大家从中体会到了什么道理？</p><p>（只要努力，弯的都能掰直！）</p><p>随着叠加的递增，所有正弦波中上升的部分逐渐让原本缓慢增加的曲线不断变陡，而所有正弦波中下降的部分又抵消了上升到最高处时继续上升的部分使其变为水平线。一个矩形就这么叠加而成了。但是要多少个正弦波叠加起来才能形成一个标准 90 度角的矩形波呢？不幸的告诉大家，答案是无穷多个。（上帝：我能让你们猜着我？）</p><p>不仅仅是矩形，你能想到的任何波形都是可以如此方法用正弦波叠加起来的。这是没有接触过傅里叶分析的人在直觉上的第一个难点，但是一旦接受了这样的设定，游戏就开始有意思起来了。</p><p>还是上图的正弦波累加成矩形波，我们换一个角度来看看：</p><p><img src="http://ww1.sinaimg.cn/mw690/7cc829d3gw1eh5v4zmdijj20go0qun0b.jpg" alt="img"></p><p>在这几幅图中，最前面黑色的线就是所有正弦波叠加而成的总和，也就是越来越接近矩形波的那个图形。而后面依不同颜色排列而成的正弦波就是组合为矩形波的各个分量。这些正弦波按照频率从低到高从前向后排列开来，而每一个波的振幅都是不同的。一定有细心的读者发现了，每两个正弦波之间都还有一条直线，那并不是分割线，而是振幅为 0 的正弦波！也就是说，为了组成特殊的曲线，有些正弦波成分是不需要的。</p><p>这里，不同频率的正弦波我们成为频率分量。</p><p><strong>好了，关键的地方来了！！</strong></p><p>如果我们把第一个频率最低的频率分量看作“1”，我们就有了构建频域的最基本单元。</p><p>对于我们最常见的有理数轴，数字“1”就是有理数轴的基本单元。</p><p>（好吧，数学称法为——基。在那个年代，这个字还没有其他奇怪的解释，后面还有正交基这样的词汇我会说吗?）</p><p>时域的基本单元就是“1 秒”，如果我们将一个角频率为<img src="http://images.cnitblog.com/news/66372/201405/271732411343005.png" alt="\omega_{0} ">的正弦波 cos（<img src="http://images.cnitblog.com/news/66372/201405/271732412442504.png" alt="\omega_{0} ">t）看作基础，那么频域的基本单元就是<img src="http://images.cnitblog.com/news/66372/201405/271732416978431.png" alt="\omega_{0} ">。</p><p>有了“1”，还要有“0”才能构成世界，那么频域的“0”是什么呢？cos（0t）就是一个周期无限长的正弦波，也就是一条直线！所以在频域，0 频率也被称为直流分量，在傅里叶级数的叠加中，它仅仅影响全部波形相对于数轴整体向上或是向下而不改变波的形状。</p><p>接下来，让我们回到初中，回忆一下已经死去的八戒，啊不，已经死去的老师是怎么定义正弦波的吧。</p><p><img src="http://ww2.sinaimg.cn/large/7cc829d3gw1egu4n8nmvhg20fk05lmxo.gif" alt="img"></p><p>正弦波就是一个圆周运动在一条直线上的投影。所以频域的基本单元也可以理解为一个始终在旋转的圆</p><p><img src="http://ww4.sinaimg.cn/mw690/7cc829d3gw1egu4mtx2sjg2074074tha.gif" alt="img"></p><p>想看动图的同学请戳这里：</p><p><a href="http://en.wikipedia.org/wiki/File:Fourier_series_square_wave_circles_animation.gif" target="_blank" rel="noopener">File:Fourier series square wave circles animation.gif</a></p><p><img src="http://images.cnitblog.com/news/66372/201405/271734071031740.gif" alt="File:Fourier series sawtooth wave circles animation.gif"></p><p>以及这里：</p><p><a href="http://en.wikipedia.org/wiki/File:Fourier_series_sawtooth_wave_circles_animation.gif" target="_blank" rel="noopener">File:Fourier series sawtooth wave circles animation.gif</a></p><p>点出去的朋友不要被 wiki 拐跑了，wiki 写的哪有这里的文章这么没节操是不是。</p><p>介绍完了频域的基本组成单元，我们就可以看一看一个矩形波，在频域里的另一个模样了：</p><p><img src="http://ww2.sinaimg.cn/mw690/7cc829d3gw1eh5v5098jzj20go0btq3q.jpg" alt="img"><br>这是什么奇怪的东西？</p><p>这就是矩形波在频域的样子，是不是完全认不出来了？教科书一般就给到这里然后留给了读者无穷的遐想，以及无穷的吐槽，其实教科书只要补一张图就足够了：频域图像，也就是俗称的频谱，就是——</p><p><img src="http://ww2.sinaimg.cn/mw690/7cc829d3gw1eh5v53i4kjj20go07iab8.jpg" alt="img"></p><p>再清楚一点：</p><p><img src="http://ww2.sinaimg.cn/mw690/7cc829d3gw1eh5v57q4vij20go0a0gn0.jpg" alt="img"></p><p>可以发现，在频谱中，偶数项的振幅都是0，也就对应了图中的彩色直线。振幅为 0 的正弦波。</p><p><img src="http://images.cnitblog.com/news/66372/201405/271734446194512.gif" alt="File:Fourier series and transform.gif"></p><p>动图请戳：</p><p><a href="http://en.wikipedia.org/wiki/File:Fourier_series_and_transform.gif" target="_blank" rel="noopener">File:Fourier series and transform.gif</a></p><p>老实说，在我学傅里叶变换时，维基的这个图还没有出现，那时我就想到了这种表达方法，而且，后面还会加入维基没有表示出来的另一个谱——相位谱。</p><p>但是在讲相位谱之前，我们先回顾一下刚刚的这个例子究竟意味着什么。记得前面说过的那句“世界是静止的”吗？估计好多人对这句话都已经吐槽半天了。想象一下，世界上每一个看似混乱的表象，实际都是一条时间轴上不规则的曲线，但实际这些曲线都是由这些无穷无尽的正弦波组成。我们看似不规律的事情反而是规律的正弦波在时域上的投影，而正弦波又是一个旋转的圆在直线上的投影。那么你的脑海中会产生一个什么画面呢？</p><p>我们眼中的世界就像皮影戏的大幕布，幕布的后面有无数的齿轮，大齿轮带动小齿轮，小齿轮再带动更小的。在最外面的小齿轮上有一个小人——那就是我们自己。我们只看到这个小人毫无规律的在幕布前表演，却无法预测他下一步会去哪。而幕布后面的齿轮却永远一直那样不停的旋转，永不停歇。这样说来有些宿命论的感觉。说实话，这种对人生的描绘是我一个朋友在我们都是高中生的时候感叹的，当时想想似懂非懂，直到有一天我学到了傅里叶级数……</p><h2 id="傅里叶级数（Fourier-Series）的相位谱"><a href="#傅里叶级数（Fourier-Series）的相位谱" class="headerlink" title="傅里叶级数（Fourier Series）的相位谱"></a>傅里叶级数（Fourier Series）的相位谱</h2><p>上一章的关键词是：从侧面看。这一章的关键词是：从下面看。</p><p>在这一章最开始，我想先回答很多人的一个问题：傅里叶分析究竟是干什么用的？这段相对比较枯燥，已经知道了的同学可以直接跳到下一个分割线。</p><p>先说一个最直接的用途。无论听广播还是看电视，我们一定对一个词不陌生——频道。频道频道，就是频率的通道，不同的频道就是将不同的频率作为一个通道来进行信息传输。下面大家尝试一件事：</p><p>先在纸上画一个sin（x），不一定标准，意思差不多就行。不是很难吧。</p><p>好，接下去画一个sin（3x）+sin（5x）的图形。</p><p>别说标准不标准了，曲线什么时候上升什么时候下降你都不一定画的对吧？</p><p>好，画不出来不要紧，我把sin（3x）+sin（5x）的曲线给你，但是前提是你不知道这个曲线的方程式，现在需要你把sin（5x）给我从图里拿出去，看看剩下的是什么。这基本是不可能做到的。</p><p>但是在频域呢？则简单的很，无非就是几条竖线而已。</p><p>所以很多在时域看似不可能做到的数学操作，在频域相反很容易。这就是需要傅里叶变换的地方。尤其是从某条曲线中去除一些特定的频率成分，这在工程上称为滤波，是信号处理最重要的概念之一，只有在频域才能轻松的做到。</p><p>再说一个更重要，但是稍微复杂一点的用途——求解微分方程。（这段有点难度，看不懂的可以直接跳过这段）微分方程的重要性不用我过多介绍了。各行各业都用的到。但是求解微分方程却是一件相当麻烦的事情。因为除了要计算加减乘除，还要计算微分积分。而傅里叶变换则可以让微分和积分在频域中变为乘法和除法，大学数学瞬间变小学算术有没有。</p><p>傅里叶分析当然还有其他更重要的用途，我们随着讲随着提。</p><p>————————————————————————————————————</p><p>下面我们继续说相位谱：</p><p>通过时域到频域的变换，我们得到了一个从侧面看的频谱，但是这个频谱并没有包含时域中全部的信息。因为频谱只代表每一个对应的正弦波的振幅是多少，而没有提到相位。基础的正弦波A.sin(wt+θ)中，振幅，频率，相位缺一不可，不同相位决定了波的位置，所以对于频域分析，仅仅有频谱（振幅谱）是不够的，我们还需要一个相位谱。那么这个相位谱在哪呢？我们看下图，这次为了避免图片太混论，我们用7个波叠加的图。</p><p><img src="http://ww4.sinaimg.cn/mw690/7cc829d3gw1eh5v58ov24j20go0hutao.jpg" alt="img"></p><p>鉴于正弦波是周期的，我们需要设定一个用来标记正弦波位置的东西。在图中就是那些小红点。小红点是距离频率轴最近的波峰，而这个波峰所处的位置离频率轴有多远呢？为了看的更清楚，我们将红色的点投影到下平面，投影点我们用粉色点来表示。当然，这些粉色的点只标注了波峰距离频率轴的距离，并不是相位。</p><p><img src="http://ww4.sinaimg.cn/mw690/7cc829d3gw1eh5v5cn9yrj20go0fsgmu.jpg" alt="img"><br>这里需要纠正一个概念：时间差并不是相位差。如果将全部周期看作2Pi或者360度的话，相位差则是时间差在一个周期中所占的比例。我们将时间差除周期再乘2Pi，就得到了相位差。</p><p>在完整的立体图中，我们将投影得到的时间差依次除以所在频率的周期，就得到了最下面的相位谱。所以，频谱是从侧面看，相位谱是从下面看。下次偷看女生裙底被发现的话，可以告诉她：“对不起，我只是想看看你的相位谱。”</p><p>注意到，相位谱中的相位除了0，就是Pi。因为cos（t+Pi）=-cos（t），所以实际上相位为Pi的波只是上下翻转了而已。对于周期方波的傅里叶级数，这样的相位谱已经是很简单的了。另外值得注意的是，由于cos（t+2Pi）=cos（t），所以相位差是周期的，pi和3pi，5pi，7pi都是相同的相位。人为定义相位谱的值域为(-pi，pi]，所以图中的相位差均为Pi。</p><p>最后来一张大集合：</p><p><img src="http://ww1.sinaimg.cn/mw690/7cc829d3gw1eh5v5dhli2j20go0dtwga.jpg" alt="img"></p><h2 id="傅里叶变换（Fourier-Tranformation）"><a href="#傅里叶变换（Fourier-Tranformation）" class="headerlink" title="傅里叶变换（Fourier Tranformation）"></a>傅里叶变换（Fourier Tranformation）</h2><p>相信通过前面三章，大家对频域以及傅里叶级数都有了一个全新的认识。但是文章在一开始关于钢琴琴谱的例子我曾说过，这个栗子是一个公式错误，但是概念典型的例子。所谓的公式错误在哪里呢？</p><p>傅里叶级数的本质是将一个周期的信号分解成无限多分开的（离散的）正弦波，但是宇宙似乎并不是周期的。曾经在学数字信号处理的时候写过一首打油诗：</p><h3 id="往昔连续非周期，"><a href="#往昔连续非周期，" class="headerlink" title="往昔连续非周期，"></a>往昔连续非周期，</h3><h3 id="回忆周期不连续，"><a href="#回忆周期不连续，" class="headerlink" title="回忆周期不连续，"></a>回忆周期不连续，</h3><h3 id="任你ZT、DFT，"><a href="#任你ZT、DFT，" class="headerlink" title="任你ZT、DFT，"></a>任你ZT、DFT，</h3><h3 id="还原不回去。"><a href="#还原不回去。" class="headerlink" title="还原不回去。"></a>还原不回去。</h3><p>（请无视我渣一样的文学水平……）</p><p>在这个世界上，有的事情一期一会，永不再来，并且时间始终不曾停息地将那些刻骨铭心的往昔连续的标记在时间点上。但是这些事情往往又成为了我们格外宝贵的回忆，在我们大脑里隔一段时间就会周期性的蹦出来一下，可惜这些回忆都是零散的片段，往往只有最幸福的回忆，而平淡的回忆则逐渐被我们忘却。因为，往昔是一个连续的非周期信号，而回忆是一个周期离散信号。</p><p>是否有一种数学工具将连续非周期信号变换为周期离散信号呢？抱歉，真没有。</p><p>比如傅里叶级数，在时域是一个周期且连续的函数，而在频域是一个非周期离散的函数。这句话比较绕嘴，实在看着费事可以干脆回忆第一章的图片。</p><p>而在我们接下去要讲的傅里叶变换，则是将一个时域非周期的连续信号，转换为一个在频域非周期的连续信号。</p><p>算了，还是上一张图方便大家理解吧：</p><p><img src="http://ww4.sinaimg.cn/large/7cc829d3gw1eh5q2g0nhuj20go08baan.jpg" alt="img"></p><p>或者我们也可以换一个角度理解：傅里叶变换实际上是对一个周期无限大的函数进行傅里叶变换。</p><p>所以说，钢琴谱其实并非一个连续的频谱，而是很多在时间上离散的频率，但是这样的一个贴切的比喻真的是很难找出第二个来了。</p><p>因此在傅里叶变换在频域上就从离散谱变成了连续谱。那么连续谱是什么样子呢？</p><p><strong>你见过大海么？</strong></p><p>为了方便大家对比，我们这次从另一个角度来看频谱，还是傅里叶级数中用到最多的那幅图，我们从频率较高的方向看。</p><p><img src="http://ww1.sinaimg.cn/mw690/7cc829d3gw1eh5q2gl2u3j20go07z756.jpg" alt="img"></p><p>以上是离散谱，那么连续谱是什么样子呢？</p><p>尽情的发挥你的想象，想象这些离散的正弦波离得越来越近，逐渐变得连续……</p><p>直到变得像波涛起伏的大海：</p><p><img src="http://ww1.sinaimg.cn/mw690/7cc829d3gw1eh5q2i13r8j20go08smyb.jpg" alt="img"></p><p>很抱歉，为了能让这些波浪更清晰的看到，我没有选用正确的计算参数，而是选择了一些让图片更美观的参数，不然这图看起来就像屎一样了。</p><p>不过通过这样两幅图去比较，大家应该可以理解如何从离散谱变成了连续谱的了吧？原来离散谱的叠加，变成了连续谱的累积。所以在计算上也从求和符号变成了积分符号。</p><p>不过，这个故事还没有讲完，接下去，我保证让你看到一幅比上图更美丽壮观的图片，但是这里需要介绍到一个数学工具才能然故事继续，这个工具就是——</p><h2 id="宇宙耍帅第一公式：欧拉公式"><a href="#宇宙耍帅第一公式：欧拉公式" class="headerlink" title="宇宙耍帅第一公式：欧拉公式"></a>宇宙耍帅第一公式：欧拉公式</h2><p>虚数i这个概念大家在高中就接触过，但那时我们只知道它是-1 的平方根，可是它真正的意义是什么呢?</p><p><img src="http://ww4.sinaimg.cn/large/7cc829d3gw1eh5q2ioeygj20go03cwep.jpg" alt="img"><br>这里有一条数轴，在数轴上有一个红色的线段，它的长度是1。当它乘以 3 的时候，它的长度发生了变化，变成了蓝色的线段，而当它乘以-1 的时候，就变成了绿色的线段，或者说线段在数轴上围绕原点旋转了 180 度。</p><p>我们知道乘-1 其实就是乘了两次 i 使线段旋转了 180 度，那么乘一次 i 呢——答案很简单——旋转了 90 度。</p><p><img src="http://ww3.sinaimg.cn/mw690/7cc829d3gw1eh5q2kqrs0j20go09iaaq.jpg" alt="img"></p><p>同时，我们获得了一个垂直的虚数轴。实数轴与虚数轴共同构成了一个复数的平面，也称复平面。这样我们就了解到，乘虚数i的一个功能——旋转。</p><p>现在，就有请宇宙第一耍帅公式欧拉公式隆重登场——</p><p><img src="http://images.cnitblog.com/news/66372/201406/071037530204619.jpg" alt="img"><br>这个公式在数学领域的意义要远大于傅里叶分析，但是乘它为宇宙第一耍帅公式是因为它的特殊形式——当x等于 Pi 的时候。</p><p><img src="http://images.cnitblog.com/news/66372/201406/071037530679604.jpg" alt="img"><br>经常有理工科的学生为了跟妹子表现自己的学术功底，用这个公式来给妹子解释数学之美：”石榴姐你看，这个公式里既有自然底数e，自然数 1 和0，虚数i还有圆周率 pi，它是这么简洁，这么美丽啊！“但是姑娘们心里往往只有一句话：”臭屌丝……“</p><p>这个公式关键的作用，是将正弦波统一成了简单的指数形式。我们来看看图像上的涵义：</p><p><img src="http://ww1.sinaimg.cn/mw690/7cc829d3gw1eh5q2kwv90j20go08b0tx.jpg" alt="img"></p><p>欧拉公式所描绘的，是一个随着时间变化，在复平面上做圆周运动的点，随着时间的改变，在时间轴上就成了一条螺旋线。如果只看它的实数部分，也就是螺旋线在左侧的投影，就是一个最基础的余弦函数。而右侧的投影则是一个正弦函数。</p><p>关于复数更深的理解，大家可以参考：</p><p><a href="http://www.zhihu.com/question/23234701/answer/26017000" target="_blank" rel="noopener">复数的物理意义是什么？</a></p><p>这里不需要讲的太复杂，足够让大家理解后面的内容就可以了。</p><h2 id="指数形式的傅里叶变换"><a href="#指数形式的傅里叶变换" class="headerlink" title="指数形式的傅里叶变换"></a>指数形式的傅里叶变换</h2><p>有了欧拉公式的帮助，我们便知道：正弦波的叠加，也可以理解为螺旋线的叠加在实数空间的投影。而螺旋线的叠加如果用一个形象的栗子来理解是什么呢？</p><p><strong>　　光波</strong></p><p>高中时我们就学过，自然光是由不同颜色的光叠加而成的，而最著名的实验就是牛顿师傅的三棱镜实验：</p><p><img src="http://ww2.sinaimg.cn/mw690/7cc829d3gw1eh5q2na8puj207p04uwef.jpg" alt="img"></p><p>所以其实我们在很早就接触到了光的频谱，只是并没有了解频谱更重要的意义。</p><p>但不同的是，傅里叶变换出来的频谱不仅仅是可见光这样频率范围有限的叠加，而是频率从 0 到无穷所有频率的组合。</p><p>这里，我们可以用两种方法来理解正弦波：</p><p>第一种前面已经讲过了，就是螺旋线在实轴的投影。</p><p>另一种需要借助欧拉公式的另一种形式去理解：</p><p><img src="http://images.cnitblog.com/news/66372/201406/071037533339291.png" alt="e^{it}=cos (t) +i.sin (t)"><br><img src="http://images.cnitblog.com/news/66372/201406/071037541452176.png" alt="e^{-it}=cos (t)-i.sin (t)"></p><p>将以上两式相加再除2，得到：</p><p><img src="http://ww2.sinaimg.cn/mw690/7cc829d3gw1eh5q2uzxlfj203k010t8h.jpg" alt="img"></p><p>这个式子可以怎么理解呢？</p><p>我们刚才讲过，e^(it)可以理解为一条逆时针旋转的螺旋线，那么e^(-it)则可以理解为一条顺时针旋转的螺旋线。而 cos (t)则是这两条旋转方向不同的螺旋线叠加的一半，因为这两条螺旋线的虚数部分相互抵消掉了！</p><p>举个例子的话，就是极化方向不同的两束光波，磁场抵消，电场加倍。</p><p>这里，逆时针旋转的我们称为正频率，而顺时针旋转的我们称为负频率（注意不是复频率）。</p><p>好了，刚才我们已经看到了大海——连续的傅里叶变换频谱，现在想一想，连续的螺旋线会是什么样子：</p><p>想象一下再往下翻：</p><p><img src="http://ww3.sinaimg.cn/mw690/7cc829d3gw1eh5q2psb9wj20m80h8wi6.jpg" alt="img"></p><p>是不是很漂亮？</p><p>你猜猜，这个图形在时域是什么样子？</p><p><img src="http://ww4.sinaimg.cn/mw690/7cc829d3gw1eh5q2sq0eqj20go0d33z1.jpg" alt="img"></p><p>哈哈，是不是觉得被狠狠扇了一个耳光。数学就是这么一个把简单的问题搞得很复杂的东西。</p><p>顺便说一句，那个像大海螺一样的图，为了方便观看，我仅仅展示了其中正频率的部分，负频率的部分没有显示出来。</p><p>如果你认真去看，海螺图上的每一条螺旋线都是可以清楚的看到的，每一条螺旋线都有着不同的振幅（旋转半径），频率（旋转周期）以及相位。而将所有螺旋线连成平面，就是这幅海螺图了。</p><p>好了，讲到这里，相信大家对傅里叶变换以及傅里叶级数都有了一个形象的理解了，我们最后用一张图来总结一下：</p><p><img src="http://ww4.sinaimg.cn/mw690/7cc829d3gw1eh5q2t82oxj20go0r8acj.jpg" alt="img"></p><p>好了，傅里叶的故事终于讲完了，下面来讲讲我的故事：</p><p>这篇文章第一次被卸下来的地方你们绝对猜不到在哪，是在一张高数考试的卷子上。当时为了刷分，我重修了高数（上），但是后来时间紧压根没复习，所以我就抱着裸考的心态去了考场。但是到了考场我突然意识到，无论如何我都不会比上次考的更好了，所以干脆写一些自己对于数学的想法吧。于是用了一个小时左右的时间在试卷上洋洋洒洒写了本文的第一草稿。</p><p>你们猜我的了多少分？</p><p>6 分</p><p>没错，就是这个数字。而这 6 分的成绩是因为最后我实在无聊，把选择题全部填上了C，应该是中了两道，得到了这宝贵的 6 分。说真的，我很希望那张卷子还在，但是应该不太可能了。</p><p>那么你们猜猜我第一次信号与系统考了多少分呢？</p><p>45 分</p><p>没错，刚刚够参加补考的。但是我心一横没去考，决定重修。因为那个学期在忙其他事情，学习真的就抛在脑后了。但是我知道这是一门很重要的课，无论如何我要吃透它。说真的，信号与系统这门课几乎是大部分工科课程的基础，尤其是通信专业。</p><p>在重修的过程中，我仔细分析了每一个公式，试图给这个公式以一个直观的理解。虽然我知道对于研究数学的人来说，这样的学习方法完全没有前途可言，因为随着概念愈加抽象，维度越来越高，这种图像或者模型理解法将完全丧失作用。但是对于一个工科生来说，足够了。</p><p>后来来了德国，这边学校要求我重修信号与系统时，我彻底无语了。但是没办法，德国人有时对中国人就是有种藐视，觉得你的教育不靠谱。所以没办法，再来一遍吧。</p><p>这次，我考了满分，而及格率只有一半。</p><p>老实说，数学工具对于工科生和对于理科生来说，意义是完全不同的。工科生只要理解了，会用，会查，就足够了。但是很多高校却将这些重要的数学课程教给数学系的老师去教。这样就出现一个问题，数学老师讲得天花乱坠，又是推理又是证明，但是学生心里就只有一句话：学这货到底干嘛用的？</p><p>缺少了目标的教育是彻底的失败。</p><p>在开始学习一门数学工具的时候，学生完全不知道这个工具的作用，现实涵义。而教材上有只有晦涩难懂，定语就二十几个字的概念以及看了就眼晕的公式。能学出兴趣来就怪了！</p><p>好在我很幸运，遇到了大连海事大学的吴楠老师。他的课全程来看是两条线索，一条从上而下，一条从下而上。先将本门课程的意义，然后指出这门课程中会遇到哪样的问题，让学生知道自己学习的某种知识在现实中扮演的角色。然后再从基础讲起，梳理知识树，直到延伸到另一条线索中提出的问题，完美的衔接在一起！</p><p>这样的教学模式，我想才是大学里应该出现的。</p><p>最后，写给所有给我点赞并留言的同学。真的谢谢大家的支持，也很抱歉不能一一回复。因为知乎专栏的留言要逐次加载，为了看到最后一条要点很多次加载。当然我都坚持看完了，只是没办法一一回复。</p><p>本文只是介绍了一种对傅里叶分析新颖的理解方法，对于求学，还是要踏踏实实弄清楚公式和概念，学习，真的没有捷径。但至少通过本文，我希望可以让这条漫长的路变得有意思一些。</p><p>最后，祝大家都能在学习中找到乐趣…</p>]]></content>
    
    <summary type="html">
    
      一篇非常好的介绍傅里叶变换的文章，相信很多人也看过
    
    </summary>
    
      <category term="数学" scheme="http://yushiyang.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="AI" scheme="http://yushiyang.top/tags/AI/"/>
    
      <category term="数学" scheme="http://yushiyang.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="转载" scheme="http://yushiyang.top/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>snoopy</title>
    <link href="http://yushiyang.top/2017/10/13/snoopy/"/>
    <id>http://yushiyang.top/2017/10/13/snoopy/</id>
    <published>2017-10-13T01:14:31.000Z</published>
    <updated>2017-10-13T02:44:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知道大家有没有这种经历，就是我想找个一个API但是网上没有，这个时候我只能找类似的网站，里面有个表单我输入我想要获取的东西，它网页返回相应的数据，这时候我们用这个snoopy类就比较方便了</p><h2 id="snoopy是什么"><a href="#snoopy是什么" class="headerlink" title="snoopy是什么"></a>snoopy是什么</h2><p>snoopy是一个php类，用来模仿web浏览器的功能，它能完成获取网页内容和发送表单的任务，这里是他的<a href="https://sourceforge.net/projects/snoopy/files/" target="_blank" rel="noopener">下载地址</a></p><h2 id="snoopy的一些功能特点"><a href="#snoopy的一些功能特点" class="headerlink" title="snoopy的一些功能特点"></a>snoopy的一些功能特点</h2><ul><li>抓取网页的内容fetch()</li><li>抓取网页的文本内容（去除html标签）fetchtext()</li><li>抓取网页的链接，表单 fetchlinks() fetchform()</li><li>支持代理主机</li><li>支持基本的用户名/密码验证</li><li>支持设置user_agent, referer(来路), cookies 和header content(头文件)</li><li>支持浏览器重定向，并能控制重定向深度</li><li>能把网页中的链接扩展成高的url(默认)</li><li>提交数据并且获取返回值</li><li>支持跟踪HTML框架</li><li>支持重定向的时候传递cookies</li></ul><p>要求php4以上就可以了，由于本身就是一个php类，无需扩支持，服务器不支持curl时候的最好选择</p><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p><strong>fetch($url)</strong></p><p>   抓取网页的内容，抓取的结果被存储在$this-&gt;results中。</p><p>   如果你正在抓取的是一个框架，Snoopy将每个框架追踪后存入数组中，然后存入$this-&gt;results.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include(&quot;./Snoopy.class.php&quot;);  //引入snoopy类</span><br><span class="line">$snoopy = new Snoopy;</span><br><span class="line">$snoopy-&gt;fetch(&apos;http://yushiyang.top/&apos;); //以本站为例</span><br><span class="line">echo $snoopy-&gt;results;</span><br></pre></td></tr></table></figure><p>这样就可以抓到本站相关的信息了，是不是很简单</p><p><strong>其他方法</strong></p><p>因为其他方法使用和fetch()差不多，我就不一一举例，只是告诉大家有哪些，作用是什么。</p><ul><li>fetchtext($url)</li></ul><p>本方法类似于fetch(),唯一不同的就是本方法去除html标签和其他的无关数据，只返回网页中的文字内容。</p><ul><li>fetchlinks($url)</li></ul><p>本方法类似于fetch(),唯一不同的就是本方法只返回网页中的链接，默认情况下，相对链接将自动补全，转换成完整的url。</p><ul><li>fetchform($url)</li></ul><p>同理，只返回网页中表单内容(from)。</p><ul><li>submit($url,formvars)</li></ul><p>本方法向$url指定的链接地址发送确认的表单，而$fromvars 是一个存储表单参数的数组。</p><ul><li>submittext($url,formvars)</li></ul><p>本方法类似于submit(),唯一不同的就是去除html标签和其他的无关的数据，只返回登录后网页中的文字内容</p><ul><li>submitlinks($url)</li></ul><p>本方法类似于submit(),唯一不同的就是只返回网页中的链接，默认情况下，相对链接会自动补全，转换成完整的url。</p><h2 id="类属性（缺省值在括号里）"><a href="#类属性（缺省值在括号里）" class="headerlink" title="类属性（缺省值在括号里）"></a>类属性（缺省值在括号里）</h2><ul><li>$host 连接的主机</li><li>$port 连接的端口</li><li>$proxy_host 使用的代理主机，如果有的话</li><li>$proxy_port 使用的代理主机端口，如果有的话</li><li>$agent 用户代理伪装 (Snoopy v0.1)</li><li>$referer 来路信息，如果有的话</li><li>$cookies cookies， 如果有的话</li><li>$rawheaders 其他的头信息, 如果有的话</li><li>$maxredirs 最大重定向次数， 0=不允许 (5)</li><li>$offsiteok whether or not to allow redirects off-site. (true)</li><li>$expandlinks 是否将链接都补全为完整地址 (true)</li><li>$user 认证用户名, 如果有的话</li><li>$pass 认证用户名, 如果有的话</li><li>$accept http 接受类型 (image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, <em>/</em>)</li><li>$error 哪里报错, 如果有的话</li><li>$response_code 从服务器返回的响应代码</li><li>$headers 从服务器返回的头信息</li><li>$maxlength 最长返回数据长度</li><li>$read_timeout 读取操作超时 (requires PHP 4 Beta 4 )，设置为0为没有超时</li><li>$timed_out 如果一次读取操作超时了，本属性返回 true (requires PHP 4 Beta 4 )</li><li>$maxframes 允许追踪的框架最大数量</li><li>$status 抓取的http的状态</li><li>$temp_dir 网页服务器能够写入的临时文件目录 (/tmp)</li><li>$curl_path cURL binary 的目录, 如果没有cURL binary就设置为 false</li></ul><p><strong>Demo</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">proxy_host = &quot;127.0.0.1&quot;;</span><br><span class="line">$snoopy-&gt;proxy_port = &quot;80&quot;;</span><br><span class="line"></span><br><span class="line">$snoopy-&gt;agent = &quot;(compatible; MSIE 4.01; MSN 2.5; AOL 4.0; Windows 98)&quot;;</span><br><span class="line">$snoopy-&gt;referer = &quot;http://www.lovean.com&quot;;</span><br><span class="line"></span><br><span class="line">$snoopy-&gt;cookies[&quot;SessionID&quot;] = 238472834723489;</span><br><span class="line">$snoopy-&gt;cookies[&quot;favoriteColor&quot;] = &quot;RED&quot;;</span><br><span class="line"></span><br><span class="line">$snoopy-&gt;rawheaders[&quot;Pragma&quot;] = &quot;no-cache&quot;;</span><br><span class="line"></span><br><span class="line">$snoopy-&gt;maxredirs = 2;</span><br><span class="line">$snoopy-&gt;offsiteok = false;</span><br><span class="line">$snoopy-&gt;expandlinks = false;</span><br><span class="line"></span><br><span class="line">$snoopy-&gt;user = &quot;joe&quot;;</span><br><span class="line">$snoopy-&gt;pass = &quot;bloe&quot;;</span><br><span class="line"></span><br><span class="line">if($snoopy-&gt;fetchtext(&quot;http://www.lovean.com&quot;))</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;</span><br><span class="line">&quot;.htmlspecialchars($snoopy-&gt;results).&quot;</span><br><span class="line">n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">echo &quot;error fetching document: &quot;.$snoopy-&gt;error.&quot;n&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>提交表单</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">submit($action,$formvars);//$formvars为提交的数组</span><br><span class="line">echo $snoopy-&gt;results; //获取表单提交后的 返回的结果</span><br><span class="line">//可选以下</span><br><span class="line">$snoopy-&gt;submittext; //提交后只返回 去除html的 文本</span><br><span class="line">$snoopy-&gt;submitlinks;//提交后只返回 链接</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>既然已经提交的表单，那就可以做很多事情，接下来我们来伪装ip,伪装浏览器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookies[&quot;PHPSESSID&quot;] = &apos;fc106b1918bd522cc863f36890e6fff7&apos;; //伪装sessionid</span><br><span class="line">$snoopy-&gt;agent = &quot;(compatible; MSIE 4.01; MSN 2.5; AOL 4.0; Windows 98)&quot;; //伪装浏览器</span><br><span class="line">$snoopy-&gt;referer = http://www.baidu.com; //伪装来源页地址 http_referer</span><br><span class="line">$snoopy-&gt;rawheaders[&quot;Pragma&quot;] = &quot;no-cache&quot;; //cache 的http头信息</span><br><span class="line">$snoopy-&gt;rawheaders[&quot;X_FORWARDED_FOR&quot;] = &quot;127.0.0.101&quot;; //伪装ip</span><br><span class="line">$snoopy-&gt;submit($action,$formvars);</span><br><span class="line">echo $snoopy-&gt;results;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>原来我们可以伪装session 伪装浏览器 ，伪装ip， haha 可以做很多事情了。例如 带验证码，验证ip 投票， 可以不停的投。</p><p>ps:这里伪装ip ，其实是伪装http头，所以一般的通过 REMOTE_ADDR 获取的ip是伪装不了，反而那些通过http头来获取ip的(可以防止代理的那种) 就可以自己来制造ip。</p><p>关于如何验证码 ，简单说下：首先用普通的浏览器， 查看页面 ， 找到验证码所对应的sessionid，同时记下sessionid和验证码值，接下来就用snoopy去伪造 。</p><p>原理：由于是同一个sessionid 所以取得的验证码和第一次输入的是一样的。</p><p><strong>有时候我们可能需要伪装更多的东西,snoopy完全为我们想到了:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proxy_host = &quot;127.0.0.1&quot;;</span><br><span class="line">$snoopy-&gt;proxy_port = &quot;8080&quot;; //使用代理</span><br><span class="line">$snoopy-&gt;maxredirs = 2; //重定向次数</span><br><span class="line">$snoopy-&gt;expandlinks = true; //是否补全链接 在采集的时候经常用到</span><br><span class="line">// 例如链接为 /images/taoav.gif 可改为它的全链接</span><br><span class="line">$snoopy-&gt;maxframes = 5 //允许的最大框架数</span><br><span class="line">//注意抓取框架的时候 $snoopy-&gt;results 返回的是一个数组</span><br><span class="line">$snoopy-&gt;error //返回报错信息</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="一个完整的实例"><a href="#一个完整的实例" class="headerlink" title="一个完整的实例"></a>一个完整的实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* You need the snoopy.class.php from </span><br><span class="line">* http://snoopy.sourceforge.net/</span><br><span class="line">*/</span><br><span class="line">include(&quot;snoopy.class.php&quot;);</span><br><span class="line"> </span><br><span class="line">$snoopy = new Snoopy;</span><br><span class="line">// need an proxy?:</span><br><span class="line">//$snoopy-&gt;proxy_host = &quot;my.proxy.host&quot;;</span><br><span class="line">//$snoopy-&gt;proxy_port = &quot;8080&quot;;</span><br><span class="line"> </span><br><span class="line">// set browser and referer:</span><br><span class="line">$snoopy-&gt;agent = &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&quot;;</span><br><span class="line">$snoopy-&gt;referer = &quot;http://www.jonasjohn.de/&quot;;</span><br><span class="line"> </span><br><span class="line">// set some cookies:</span><br><span class="line">$snoopy-&gt;cookies[&quot;SessionID&quot;] = &apos;238472834723489&apos;;</span><br><span class="line">$snoopy-&gt;cookies[&quot;favoriteColor&quot;] = &quot;blue&quot;;</span><br><span class="line"> </span><br><span class="line">// set an raw-header:</span><br><span class="line">$snoopy-&gt;rawheaders[&quot;Pragma&quot;] = &quot;no-cache&quot;;</span><br><span class="line"> </span><br><span class="line">// set some internal variables:</span><br><span class="line">$snoopy-&gt;maxredirs = 2;</span><br><span class="line">$snoopy-&gt;offsiteok = false;</span><br><span class="line">$snoopy-&gt;expandlinks = false;</span><br><span class="line"> </span><br><span class="line">// set username and password (optional)</span><br><span class="line">//$snoopy-&gt;user = &quot;joe&quot;;</span><br><span class="line">//$snoopy-&gt;pass = &quot;bloe&quot;;</span><br><span class="line"> </span><br><span class="line">// fetch the text of the website www.google.com:</span><br><span class="line">if($snoopy-&gt;fetchtext(&quot;http://www.google.com&quot;))&#123; </span><br><span class="line">    // other methods: fetch, fetchform, fetchlinks, submittext and submitlinks</span><br><span class="line"> </span><br><span class="line">    // response code:</span><br><span class="line">    print &quot;response code: &quot;.$snoopy-&gt;response_code.&quot;</span><br><span class="line">n&quot;;</span><br><span class="line"> </span><br><span class="line">    // print the headers:</span><br><span class="line"> </span><br><span class="line">    print &quot;Headers:</span><br><span class="line">&quot;;</span><br><span class="line">    while(list($key,$val) = each($snoopy-&gt;headers))&#123;</span><br><span class="line">        print $key.&quot;: &quot;.$val.&quot;</span><br><span class="line">n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    print &quot;</span><br><span class="line">n&quot;;</span><br><span class="line"> </span><br><span class="line">    // print the texts of the website:</span><br><span class="line">    print htmlspecialchars($snoopy-&gt;results).&quot;n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    print &quot;Snoopy: error while fetching document: &quot;.$snoopy-&gt;error.&quot;n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，snoopy的基本用法就差不多了，当然，我这里介绍的比较基础，在实践环节中使用还需要大家灵活应用。</p>]]></content>
    
    <summary type="html">
    
      一个类似于爬虫的php类，简单好用，网上的教程也很多，我这里也是简单的整理一下，以后使用时方便查阅
    
    </summary>
    
      <category term="php" scheme="http://yushiyang.top/categories/php/"/>
    
    
      <category term="原创" scheme="http://yushiyang.top/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="php" scheme="http://yushiyang.top/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>restful-(二)</title>
    <link href="http://yushiyang.top/2017/10/12/restful-%E4%BA%8C/"/>
    <id>http://yushiyang.top/2017/10/12/restful-二/</id>
    <published>2017-10-12T02:02:08.000Z</published>
    <updated>2017-10-12T02:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载至<a href="http://www.cnblogs.com/loveis715/p/4669091.html" target="_blank" rel="noopener">REST简介</a></p><h2 id="资源识别"><a href="#资源识别" class="headerlink" title="资源识别"></a>资源识别</h2><p>在一般情况下，对资源的识别通常都是REST服务设计的第一步。在准确地识别出了各资源之后，怎么用HTTP规范中的各组成来表示这些资源便是顺理成章的事情。在本节中，我们将对如何识别REST系统中的资源进行讲解。</p><p>在通常的软件开发过程中，我们常常需要分析达成某个目标所需要使用的业务逻辑，并为业务逻辑的执行提供一系列运行接口。在一些Web服务中，这些接口常常表达了某个动作，如将商品放入购物车，提交订单等。这一系列动作组合在一起就可以组成完成目标所需要执行的业务逻辑。在需要调用这些接口的时候，软件开发人员需要向这些接口所在的URL发送一个请求，从而驱使服务执行该动作。</p><p>而在REST服务中，我们所提供的各个接口则需要是一系列资源，而业务逻辑需要通过对资源的操作来完成。也就是说，REST服务中的API将不再以执行了什么动作为中心，而是以资源为中心。一些对资源的通用操作有添加，取得，修改，删除，以及对符合特定条件的资源进行列表操作。</p><p>仍然让我们以上面所举的“将商品放入购物车”这个操作为例。在一个REST系统中，购物车将被抽象为一个资源，而“将商品放入购物车”这个操作将被解释为对购物车这个资源的更新：更新购物车，以使特定商品包含在购物车内。</p><p>可能对于刚刚学习REST的各位读者而言，这种以资源为中心的描述方法有些别扭。这种描述方法的确有别于很多Web服务那样以动作为中心。而与之对应的则是系统设计步骤的改变：我们将不再首先是别完成业务逻辑所需的各动作，而是支持业务逻辑所需要的各资源。那么我们应该如何抽象出这些资源呢？首先，我们对某个操作不要再关注它所执行的动作，而是关心它所操作的宾语。通常情况下，该宾语就会是REST系统中的资源。</p><p>在这里，我们就以“提交订单”作为示例来展示如何抽象资源。</p><p>首先，在“提交订单”这个动作中，订单是宾语。因此对于该业务逻辑，其将作为一个资源存在。除此之外，在订单中还需要包含一系列信息，例如订单中所包含的商品，订单所属人等。一旦这些都可以被该REST系统中的其它资源使用，那么它们也将成为独立的资源。</p><p>但是有时候，一个动作可能并不存在着它所操作的宾语。在这种情况下，我们就需要考虑该动作产生或消除了哪个实体，或者哪个实体的状态发生了变化。这个发生了变化的实体实际上就是一种资源。例如对于登陆这一行为，其实际上在服务端创建了一个会话实例。该会话实例中则包含了登陆IP，登陆时间，以及登陆时所用的凭证等。再比如对于用户更改密码这种行为，其所操作的资源就是用户资料。</p><p>在抽象资源的过程中，我们需要按照自顶向下的方式，即首先辨识出系统中的最主要资源，然后再辨识这些主要资源的子资源，并依次进行迭代。</p><p>对主资源的抽取主要通过分析业务逻辑来完成。在得到功能需求以后，我们首先要分析这些业务逻辑所操作的宾语。这些宾语可能有两种情况：主资源或者其它资源的子资源。主资源实际上就是能够独立存在的一系列资源。而子资源则需要依附于主资源之上才能表达实际的意义。同时各个子资源也可能拥有自身的子资源。</p><p>判断一个资源是否是子资源的一个方法就是看它是否能独立地表示其具体含义。例如对于一个egoods上所销售的商品，其名称，价格，简介等属性可以清晰地描述该商品到底是什么，到底如何销售。因此这些商品实际上是一个主资源。但是每种商品所支持的邮递服务需要是一个子资源：一个商品可以支持多种邮递服务。这些邮递服务根据派送距离等需要不同的价格，也提供了不同的邮递速度。由于这些邮递服务与商家和邮递服务公司所达成的服务价格有关，并且会由于商品重量的变化而变化，因此这些邮递服务并不能为其它商家所提供的邮递服务作为参考，因此其应该作为该商品的一个子资源。</p><p>或者也可以说，如果一个资源是主资源，那么其可以被不同的资源实例包含引用而不会产生歧义。而如果一个资源是子资源，那么被不同的资源实例引用可能会产生歧义。</p><p>但是需要注意的是，一种资源可能有多种不同的表现形式。例如对于在使用列表展示各个商品的时候，egoods只需要展示商品的名称，一个对该商品的简单描述，商品的价格以及一张商品的照片。而在用户打开了该商品页之后，页面则需要显示更详尽的信息，如商品的重量，商品所在地等等。</p><p>除此之外，资源列表也有可能拥有多种不同的表现形式。举例来说，如果egoods上属于某个分类的商品太多，需要分页显示，那么这种分页是否也应该是一种资源？答案是，这些分页并不是一种资源，而其只是资源列表的一种表现方式。在每页所包含商品数量，排序规则等条件发生变化的时候，该资源列表中所包含的各个商品也会发生变化。</p><p>那么如何判断我们为REST服务所定义的资源是否合理呢？一般情况下，我都使用下面的一些判断方法：</p><p>首先，我们需要考虑对该资源的CRUD是否有意义，从而验证资源的定义是否合理。就以刚刚说到的列表的分页显示为例，我们可以想象一下如何对分页进行添加和删除？一旦删除了该分页，那么属于该分页中的各个商品也应该被删除么？而且删除了分页X的数据后，原本X + 1分页的数据将展示在X分页中。很显然，将商品的分页定义为资源并不合理。</p><p>其次，我们需要检查资源是否需要除CRUD之外的动词来操作。该方法用来检查资源中是否还有子资源没有被抽象。如果该资源还需要额外的动词，那么我们就需要考虑这些操作到底引起了什么样的状态变化，进而抽象出该资源的子资源。</p><p>除此之外，我们还需要检查这些资源是否是被整体使用，创建和删除。该方法用来探测是否一个子资源应该是一个主资源。如果在删除一个资源的时候，其子资源还可以被其它资源重用，那么该子资源实际上具有较高的重用性，应该是一个主资源。</p><h2 id="资源的URL设计"><a href="#资源的URL设计" class="headerlink" title="资源的URL设计"></a>资源的URL设计</h2><p>在前面已经提到过，统一接口约束中的第一条子约束就是每个资源都拥有一个资源标识。在正确地辨识出了一个资源之后，我们就需要为这些资源分配其所对应的URI。一个资源所对应的URI可能有多种表示方式，如到底是用单数还是复数表示资源等。因此在一个基于HTTP的REST系统中，如何组织针对各个资源的URL实际上是最重要的一部分。毕竟一个明确的，有意义并且稳定的API接口实际上是对服务对用户的一种承诺。</p><h3 id="在HTTP中，一个URL主要由以下几个部分组成："><a href="#在HTTP中，一个URL主要由以下几个部分组成：" class="headerlink" title="在HTTP中，一个URL主要由以下几个部分组成："></a>在HTTP中，一个URL主要由以下几个部分组成：</h3><ol><li>协议。即HTTP以及HTTPS。</li><li>主机名和端口。如<a href="http://www.egoods.com:8421/" target="_blank" rel="noopener">www.egoods.com:8421</a></li><li>资源的相对路径。如/api/categories。</li><li>请求参数。即由问号开始的由键值对组成的字符串：?page=1&amp;page_size=20</li></ol><p>在为一个资源设计其所对应的URL时，我们需要着重考虑第三部分和第四部分组成。</p><h3 id="通过URL来表示资源"><a href="#通过URL来表示资源" class="headerlink" title="通过URL来表示资源"></a>通过URL来表示资源</h3><p>在辨识出了REST系统中的各个资源以后，我们就需要开始为这些资源设计各自所对应的URL了。</p><p>首先要介绍的是，所有的资源都应该存在于一个相对路径之下。请读者回忆之前我们介绍的通过向/api发送一个GET请求得到所有可以被访问的资源这个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> GET /api</span><br><span class="line"> Host: www.egoods.com</span><br><span class="line"> Authorization: Basic xxxxxxxxxxxxxxxxxxx</span><br><span class="line"> Accept: application/json</span><br><span class="line"> </span><br><span class="line"> HTTP/1.1 200 OK</span><br><span class="line"> Content-Type: application/json</span><br><span class="line"> Content-Length: xxx</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">   &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">   &quot;resources&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;label&quot; : &quot;Categories&quot;,</span><br><span class="line">         &quot;description&quot; : &quot;Product categories&quot;,</span><br><span class="line">         &quot;uri&quot;: &quot;/api/categories&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">         &quot;label&quot; : &quot;Items&quot;,</span><br><span class="line">         &quot;description&quot; : &quot;All items on sell&quot;,</span><br><span class="line">         &quot;uri&quot;: &quot;/api/items&quot;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此对于从向该相对路径发送请求才能得到的各个主资源来说，将它们置于相对路径/api之下是非常合理的。</p><p>除了这个原因之外，API的版本更迭也是一个考虑。假如软件开发人员需要开发一个新版本的REST API，那么他可能就需要重新抽象并定义系统中的各个资源。但是如果两个版本的API中都拥有一个categories资源，并且系统为了保持后向兼容性同时保留了两个版本的API，那么将只有一个资源可以使用/categories这个相对路径。也正因为如此，将这些资源置于相对路径/api之下，并在第二个版本的API出现之后将新的资源抽象置于/api-v2下是一种较为流行的做法。</p><p>在明确了所有的资源都应该置于/api这样一个相对路径下之后，我们就来讲解如何为资源定义对应的URL。一个最简单的情况是：指定主资源所对应的URL。由于主资源是一类独立的资源，因此它应该直接置于/api下。例如egoods网站中的产品分类就是一个主资源，我们会为其分配如下URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/categories</span><br></pre></td></tr></table></figure><p>而对于其它主资源，如egoods网站中的产品，我们也会为其赋予一个具有类似结构的URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/items</span><br></pre></td></tr></table></figure><p>这样，每类主资源都将拥有一个特定于该类资源的URL。这些URL就对应着相应资源实例的集合。</p><p>如果需要表示某个主资源类型中的特定实例，那么我们就需要在该类主资源所对应的URL之后添加该实例的ID。如egoods网站中的食品分类的ID为1，那么其所对应的URL就将是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/categories/1</span><br></pre></td></tr></table></figure><p>一个较为特殊的情况则是，对于某种类型的主资源，整个系统将有且仅有一个该类型资源的实例。那么该资源将不再需要通过ID来访问。我能想到的一个例子就是对整个系统进行介绍的资源。该资源实例所对应的URL将是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/about</span><br></pre></td></tr></table></figure><p>而一个资源实例中还可能拥有子资源。这些子资源与资源实例之间的关系主要有两种情况：资源实例包含了一个子资源的集合，以及资源实例仅仅可以包含一个子资源。对于资源实例包含了一个子资源集合的情况，我们需要将该子资源集合的URL置于该资源的相对路径下。例如对于egoods上所销售的ID为23456的商品所提供的邮递服务，我们将使用如下的URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/items/23456/shipments</span><br></pre></td></tr></table></figure><p>在该URI中，/api/items/23456对应的就是商品本身，而该商品所提供的邮递服务则是该商品的子资源。与主资源特定实例所具有的URI类似，其中一个ID为87256的邮递服务所对应的URI则为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/items/23456/shipments/87256</span><br></pre></td></tr></table></figure><p>如果资源实例仅仅可以包含一个子资源，那么对该子资源的访问也将不再需要ID。如当前商品的折扣信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/items/23456/discount</span><br></pre></td></tr></table></figure><h2 id="单数-vs-复数"><a href="#单数-vs-复数" class="headerlink" title="单数 vs. 复数"></a>单数 vs. 复数</h2><p>接下来要考虑的一点是，资源在URL中需要由单数表示还是复数表示？这在stackoverflow等众多论坛上已经成为了一个经久不衰的话题。我们知道，在一个基于HTTP的REST系统中，一个资源所对应的URL实际上也就是对其进行操作的URL。因此适当地使用单数和复数对于该系统的用户而言有一定的指示作用。在stackoverflow上的一个常见观点是：如果一个URL所对应的资源是使用复数表示的，那么该类型的资源可能有多个。对该URL发送Get请求可能返回该资源的一个列表。反之，如果一个URL所对应的资源是使用单数表示的，那么该类型的资源将只有一个，因此对该URL发送Get请求将只返回该资源的一个实例。</p><p>以egoods中的商品分类为例。由于一个网站所售卖的商品可能有多种类别，因此其需要在URL中使用复数形式：/api/categories。而对于一个该网站的用户而言，由于其只会有一个个人偏好设置，因此其URL则需要使用单数形式：/api/users/{user_id}/preference。</p><p>你可能会问：如果需要得到具有特定ID的某个实例时，我们应该对该资源使用单数还是复数呢？答案是复数。这是因为在通过特定ID访问某个资源的实例实际上就是从该资源的集合中取出特定实例。因此表示该资源集合的URL实际上仍然需要使用复数形式，而其后所使用的ID则标明了其所访问的是资源中的单一实例，因此向这个URL发送Get请求将返回该资源的单一实例。</p><p>就以“食品”分类为例。该分类所对应的URL为/api/categories/1。该URL中的前半部分/api/categories表示egoods网站中所有分类的集合，而1则表示在该分类集合中的ID为1的分类。</p><h2 id="相对路径-vs-请求参数"><a href="#相对路径-vs-请求参数" class="headerlink" title="相对路径 vs. 请求参数"></a>相对路径 vs. 请求参数</h2><p>另一个经常导致疑惑的地方就是针对资源的某一种特征，我们到底是将其定义为URL中相对路径的一部分还是作为请求参数。</p><p>请考虑下面一个例子。在egoods网站中，我们售卖的手机主要有苹果，三星等品牌。那么在为这些手机设计URL的时候，我们是否需要按照品牌对这些手机进行细分，从而用户只要通过向/api/mobiles/brands/apple发送请求就能列出所有的苹果手机？还是说，直接将手机的品牌置于请求参数中，从而通过/api/mobiles?brand=apple来列出所有的苹果手机？</p><p>在判断到底是使用请求参数还是相对路径时，我们一般分为下面几步。</p><p>首先，可选参数一般都应置于请求参数中。仍以egoods中的手机为例。在选择手机时，用户可以选择品牌以及颜色。如果将品牌和颜色都定义在相对URL中，那么具有特定品牌和颜色的手机将可以通过两个不同的URL访问：/api/mobiles/brand/{brand}/color/{color}以及/api/mobiles/color/{color}/brand/{brand}。就用户而言，其并无法了解这两个URL所表示的是同一类资源还是不同类型的资源。当然，您可以说，我们只用/api/mobiles/brand/{brand}/color/{color}。但是该URL将无法处理用户仅仅选择了颜色，却没有选择品牌的情况。</p><p>其次，不是所有字符都可以在URL中被使用，如汉字，标点。为了处理这种情况，包含这些字符的筛选条件需要置于请求参数中。</p><p>最后，如果该特征下包含子资源，那么它自身也就是一个资源，因此需要以相对路径的方式展现它。例如在egoods网站中，每件商品所属于的分类仅仅是它的一个特征。但是一个分类更包含了属于它的各个品牌以及热搜关键字等众多信息。因此它其实是一个资源，需要在URI路径中表示它。</p><p>总的来说，既然使用HTTP来构建REST系统，那么我们就需要遵守URL各组成中的含义：URL中的相对路径将用来标示“What I want”，也既对应着资源；而请求参数则用来标示“How I want”，即查看资源的方式。</p><h2 id="使用合适的动词"><a href="#使用合适的动词" class="headerlink" title="使用合适的动词"></a>使用合适的动词</h2><p>在知道了如何为每种资源定义URI之后，我们来看看如何操作这些资源。</p><p>首先，在一个资源的生命周期之内常常会发生一系列通用事件（CRUD）。一开始，一个资源并不存在。只有用户或REST服务创建了该资源以后其才存在，也即是上面所列出的通用事件中的C，Create。在一个资源创建完毕以后，用户可能会从服务端请求该资源的表示，也就是上面所列出的通用事件的R，Retrieve。在特定情况下，用户可能决定要更新该资源，因此会使用上面的通用事件中的U，即Update来更新资源。而在资源不再需要的时候，用户可能需要通过通用事件D，即Delete来删除该资源。同时用户有时也需要列出属于特定类型资源的资源实例，即通过List操作来得到属于特定类型的资源的列表。</p><p>在前面的讲解中我们已经提到过，在REST系统中的每个资源都有一个特定的URI与之对应。HTTP协议提供了多种在URI上操作的动词，如GET，PUT，POST以及DELETE等。因此在一个基于HTTP的REST服务中，我们需要使用这些HTTP动词来表示如何对这些资源进行CRUD操作。而在什么情况下到底使用哪个动词则是由这些动词本身在HTTP协议中的意义所决定的。</p><p>这其中GET和DELETE两个动词的含义较为清晰：</p><p><em>The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.</em></p><p><em>The DELETE method requests that the origin server delete the resource identified by the Request-URI.</em></p><p>也就是说，在需要读取某个资源的时候，我们向该资源所对应的URI发送一个GET请求即可。类似的，在需要删除一个资源的时候，我们只需要向该资源所对应的URI发送一个DELETE请求即可。而在希望得到某类型资源的列表的时候，我们可以直接向该类型资源所对应的URI发送一个GET请求。</p><p>而动词PUT和POST则是较为容易混淆的两个动词。在HTTP规范中，POST的定义如下所示：</p><p><em>The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line</em></p><p>也就是说，POST动词会在目标URI之下创建一个新的子资源。例如在向服务端发送下面的请求时，REST系统将创建一个新的分类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /api/categories</span><br><span class="line">Host: www.egoods.com</span><br><span class="line">Authorization: Basic xxxxxxxxxxxxxxxxxxx</span><br><span class="line">Accept: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   &quot;label&quot; : &quot;Electronics&quot;,</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而PUT的定义则更为晦涩一些：</p><p><em>The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.”</em></p><p>也就是说，PUT则是根据请求创建或修改特定位置的资源。此时向服务端发送的请求的目标URI需要包含所处理资源的ID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 POST /api/categories/8fa866a1-735a-4a56-b69c-d7e79896015e</span><br><span class="line">2 Host: www.egoods.com</span><br><span class="line">3 Authorization: Basic xxxxxxxxxxxxxxxxxxx</span><br><span class="line">4 Accept: application/json</span><br><span class="line">5 </span><br><span class="line">6 &#123;</span><br><span class="line">7    &quot;label&quot; : &quot;Electronics&quot;,</span><br><span class="line">8    ……</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure><p>可以看到，两者都有创建的含义，但是意义却不同。在决定到底是使用PUT还是POST来创建资源的时候，软件开发人员需要考虑一系列问题：</p><p>首先就是资源的ID是如何生成的。如果希望客户端在创建资源的时候显式地指定该资源的ID，那么就需要使用PUT。而在由服务端为该资源自动赋予ID的时候，我们就需要在创建资源时使用POST。在决定使用PUT创建资源的时候，防止资源URI与其它资源所具有的URI重复的任务需要由客户端来保证。在这种情况下，客户端常常使用GUID/UUID作为将资源的ID。但是到底使用GUID/UUID还是由服务端来生成ID不仅仅和REST有关，更会对数据库性能等多个方面产生影响。因此在决定使用它们之前要仔细地考虑清楚。</p><p>同时需要注意的是，因为REST要求客户只可以通过服务端返回结果中所包含的信息来得到下一步操作所需要的信息，因此客户端仅仅可以决定资源的ID，而URI中的其它部分则需要从之前得到的响应中取得。</p><p>但是软件开发人员常常会进入另外一个误区很多人认为REST服务中的HATEOAS只能通过Hyperlink完成。实际上在Roy对REST的定义中使用的是Hypermedia，即响应中的所有多媒体信息。就像Roy在其个人网站上所说（<a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" target="_blank" rel="noopener">http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</a>）：</p><p><em>A REST API must not define fixed resource names or hierarchies (an obvious coupling of client and server). Servers must have the freedom to control their own namespace. Instead, allow servers to instruct clients on how to construct appropriate URIs, such as is done in HTML forms and URI templates, by defining those instructions within media types and link relations.</em></p><p>另外一个需要考虑的因素则是PUT的等幂性是否对REST系统的设计有所帮助。由于在同一个URI上调用两次PUT所得到的结果相同。因此用户在没有接到PUT请求响应时可以放心地重复发送该响应。这在网络丢包较为严重时是一个非常好的功能。反过来，在同一个URI上调用两次POST将可能创建两个独立的子资源。</p><p>除此之外，还需要考虑是否将资源的创建和更新归结为一个API可以简化用户对REST服务的使用。用户可以通过PUT动词来同时完成创建和更新一个资源这两种不同的任务。这样的好处在于简化了REST服务所提供的接口，但是反过来也让一个API执行了两种不同的任务，在一定程度上违反了API设计时每个API都需要有明确的意义这一原则。</p><p>因此在决定到底使用POST还是PUT来完成资源的创建之前，请考虑上面所列出的三条问题，以确定到底哪个动词更加适合。</p><p>除此之外，另外一对类似的动词则是PUT和PATCH。两者之间的不同则在于PUT是对整个资源的更新，而PATCH则是对部分资源的更新。而该动词的局限性则在于对该动词的支持程度。毕竟在某些类库中并没有提供原生的对PATCH动词的支持。</p><h2 id="使用标准的状态码"><a href="#使用标准的状态码" class="headerlink" title="使用标准的状态码"></a>使用标准的状态码</h2><p>在与REST服务进行交互的时候，用户需要通过服务所返回的信息决定其所发送的请求是否被适当地处理。这部分功能是由REST服务实现时所使用的协议所决定的，与REST架构无关。而在基于HTTP的REST服务中，该功能就由HTTP响应的状态码（Status Code）来完成。因此在设计一个REST服务时，我们需要额外地注意是否返回了正确的状态码。</p><p>但是这些预定义的HTTP状态码并不能满足所有的情况。有时候一个REST服务所希望返回的错误信息能够更加精确地描述问题，例如在用户重设密码时，我们需要在用户所输入原密码与系统中所记录的密码不匹配时返回“您所输入的密码有误”这样的消息。在HTTP协议中，我们并没有办法找到一个能够精确地表示该意义的状态码。</p><p>因此在通常情况下，REST服务都会在响应中额外地提供一个说明性的负载来告知用户到底产生了什么问题。例如对于上面的重设密码失败的情况，服务端可能会返回如下响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: xxx</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   &quot;error_id&quot; : &quot;100045&quot;,</span><br><span class="line">   &quot;header&quot; : &quot;Reset password failed&quot;,</span><br><span class="line">   &quot;description&quot; : &quot;The original password is not correct&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例响应中主要包含以下的说明性信息：</p><ol><li>服务端响应的状态码。页面逻辑可以通过判断该状态码是否是4XX或5XX来判断是否请求出错，从而在页面中展示一个警告对话框。</li><li>服务所提供的内部错误ID。通常情况下，该内部错误ID也需要在警告对话框中展示出来。从而允许软件用户根据内部错误ID来获取支持服务。</li><li>错误的标题及简述。通过该错误的标题及简述，软件用户能够了解系统内部到底发生了什么，并在是用户输入错误的时候允许用户自行修改错误并重新发送正确的请求。</li></ol><p>在该错误中，最关键的当属服务端的响应代码。一个响应代码不仅仅标示了请求是否成功，更有用户该如何操作的含义。例如对于401 Unauthorized响应代码而言，其表示该响应没有提供一个合法的身份凭证，因此需要用户首先执行登陆操作以得到一个合法的身份凭证，然后该资源可能就可以被访问了。而403 Forbidden响应代码则表示当前请求已经提供了一个合法的身份凭证，但是该身份凭证并没有访问该资源的权限，因此使用该身份凭证登陆重新登陆系统等操作并不能解决问题。</p><p>因此在返回错误信息之前，软件开发人员首先需要考虑清楚在响应中到底应该使用什么样的响应代码。而正确地选择响应代码则建立在软件开发人员对这些响应代码拥有一个正确的理解的前提下。</p><p>当然，要将所有的响应代码完全理解也需要大量的工作，而且REST服务的用户也可能并没有那么多的领域知识来了解所有的响应代码的含义。因此在很多基于HTTP的REST系统中，系统在标示错误时只使用一系列常用的响应代码，如400，401，403，404，405，500，503等。在用户请求被处理时，系统将返回200 OK，表示请求已经被处理。而在处理时发生错误时则尽量使用这些响应代码来表示。如果一个错误较为复杂，那么直接返回400或500，并在响应的负载中提供具体的错误信息。</p><p>不得不说的是，这种做法有时显得简单粗暴，尤其是对于一个开放平台而言则更是致命的。当一个第三方厂商为一个开放平台开发一个应用软件，却每次只能得到一个400错误，那么其内部应用逻辑将无法判断到底是哪里出了问题。为了能让用户知道这里产生了错误，该第三方软件只能将开放平台所给出的信息直接显示给用户。但是这些信息实际上是建立在开放平台这个语境下的，因此对于第三方厂商的用户而言，这些信息晦涩难懂，甚至可能一点帮助也没有。</p><p>也就是说，到底如何组织这些响应代码需要用户根据所编写的项目决定，尤其是该产品的使用者来决定。在定义一个平台时，尽量使用更多的HTTP响应代码，因为用户极有可能通过该平台编写自己的第三方软件。而在为一个普通的产品定义REST API时，将响应代码定得非常专业可能反而导致易用性的下降。</p><p>另外一点需要说明的是，个人不建议使用Wikipedia查找各个状态码的含义，而应该使用RFC所描述的各状态码的定义。 IANA提供了一张各个状态码所对应的RFC协议的列表，从而可以很容易地找到各个状态码所对应的RFC协议以及其所在的章节。该列表的地址为：<a href="http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml" target="_blank" rel="noopener">http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</a></p><p>之所以不建议使用Wikipedia的原因主要有两点：</p><ol><li>描述不够详细。在RFC定义中，每个状态码都对应着一段或多段文字，并且解释非常清晰。而在Wikipedia中，每个状态码常常只有一句话。</li><li>不够准确。在Wikipedia的Reference节中，我们可以看到一系列特定平台所定义的状态码，如Spring Framework所定义的420 Method Failure等。这非常具有误导性。</li></ol><h2 id="选择适当的表示结构"><a href="#选择适当的表示结构" class="headerlink" title="选择适当的表示结构"></a>选择适当的表示结构</h2><p>接下来我们要讲解的就是如何为资源定义一个恰当的表示。</p><p>首先需要强调的是，REST并没有规定其服务中需要使用什么格式来表示资源。表示资源时所可以选取的表示形式实际上是由实现REST所使用的协议决定的。而在一个基于HTTP的REST服务中，我们可以使用JSON，也可以使用XML，甚至是自定义的MIME类型来表示资源。这些表现形式常常是等效的。相信读者已经看到，本系列文章会使用JSON来表示这些资源。</p><p>一个REST服务常常会同时支持多种客户端。这些客户端可能会使用不同的协议来与服务进行沟通。而且就算是使用相同的协议，不同的客户端所可以接受的负载表示形式也会有所不同。因此客户端需要与REST服务协商在通讯过程中所使用的负载。</p><p>客户端和服务端对所使用负载类型的协商通常都按照协议所规定的标准协商过程来完成。例如对于一个基于HTTP的REST服务，我们就需要使用Accept头来标示客户端所可以接受的负载类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /api/categories</span><br><span class="line">Host: www.egoods.com</span><br><span class="line">Authorization: Basic xxxxxxxxxxxxxxxxxxx</span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure><p>而在服务端支持的情况下，返回的响应就将使用该MIME类型组织其负载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: xxx</span><br></pre></td></tr></table></figure><p>在这里我们再重复一次：REST是一种组织Web服务的架构，其只在架构方面提出了一系列约束。可以说，所有对REST的讲解都已经在前两个章节，即“REST的定义”以及“资源识别”中完成了。而有关客户端和服务端如何进行沟通，为资源定义什么样的URI，使用什么格式的数据进行沟通等讨论都是在阐述如何将REST架构所提出的各种约束和基于HTTP协议的Web服务结合在一起。毕竟在通常情况下，实现一个单纯的技术不难，但是如何将多种技术规范自然地混合在一起，构成一个自然的，成熟稳定的解决方案才是项目开发中的难点。HTTP协议并不是为REST架构所定义的，因此如何用HTTP协议来恰当地描述一个REST服务才是本文所着重介绍的。</p><h2 id="负载的自描述性"><a href="#负载的自描述性" class="headerlink" title="负载的自描述性"></a>负载的自描述性</h2><p>在前面对REST提出的几个约束的讲解中我们已经提到过，REST系统中所传递的各个消息的负载需要提供足够的用于操作该资源的信息，如如何对资源进行添加，删除以及修改等操作，并可以根据负载中所包含的对其它各资源的引用来访问各个资源。这也对负载的自描述性提出了更高的要求。</p><p>首先让我们回头看看egoods电子商务网站对食品分类的描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    &quot;uri&quot; : &quot;/api/categories/1&quot;,</span><br><span class="line">    &quot;label&quot; : &quot;Food&quot;,</span><br><span class="line">    &quot;items_url&quot; : &quot;/api/items?category=1&quot;,</span><br><span class="line">    &quot;brands&quot; : [</span><br><span class="line">          &#123;</span><br><span class="line">             &quot;label&quot; : &quot;友臣&quot;,</span><br><span class="line">             &quot;brand_key&quot; : &quot;32073&quot;,</span><br><span class="line">             &quot;url&quot; : &quot;/api/brands/32073&quot;</span><br><span class="line">         &#125;, &#123;</span><br><span class="line">            &quot;label&quot; : &quot;乐事&quot;,</span><br><span class="line">            &quot;brand_key&quot; : &quot;56632&quot;,</span><br><span class="line">            &quot;url&quot; : &quot;/api/brands/56632&quot;</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">   ],</span><br><span class="line">   &quot;hot_searches&quot; : …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想读者在看到该响应之后可能就已经明白了很多域的含义。但还是让我们依次对这些域进行讲解。</p><p>第一个要讲解的是url域。该域用来标示该资源所对应的URL。可能您会问：既然我们就是从这个URL返回的该资源，那么为什么我们还需要在该资源中保存一个它所对应的URL呢？首先这是因为在统一接口约束中要求每个资源都拥有一个资源标识。在这里我们使用URL作为标识。而另一些基于HTTP的REST系统中，用来作为资源标识的常常是该资源的ID。个人更倾向于使用URL的原因则是：在某些情况下，如对某个资源定时刷新以进行监控的时候，URL可以直接被使用。</p><p>接下来是label域。其用来记录用于展示给用户的分类名。</p><p>items_url域则用来表示取得属于该分类物品列表的URL。注意这里我使用了后缀_url以明确标明其是一个URL，需要通过跳转来取得实际的数据。</p><p>下一个域brands则用来表示属于该分类的著名商品品牌。这里我们使用了一个数组，而数组中的每个元素都表示了一个品牌。每个品牌的表示都包含了一个展示给用户的label，在搜索时所使用的键，以及该品牌所对应的url。您可能会怀疑为什么我们仅仅提供了这么少的域。这是因为他们仅仅是对这个品牌的引用，而并非是把该资源的详细信息都包含进来了的缘故。在用户希望查看该品牌的详细信息的时候，他需要向该品牌引用中所标明的品牌的URL发送一个GET请求。</p><p>而由于hot_searches域的组成及使用基本上与brands域类似，因此这里不再赘述。</p><p>在大致地了解了食品分类的JSON表示中各个域的含义后，我们就将开始讲解如何自行定义资源的JSON表示。对于一个简单的，不包含任何子资源以及对其它资源的引用的资源，我们只需要通过一个包含简单属性的JSON来表示它。例如对于一个品牌，我们可能仅仅提供了一系列描述性信息：品牌的名称，以及对品牌的简单描述。那么它所对应的JSON表示可以表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;uri&quot; : &quot;/api/brands/32059&quot;,</span><br><span class="line">   &quot;label&quot; : &quot;Dole&quot;,</span><br><span class="line">   &quot;description&quot; : &quot;An American-based agricultural multinational corporation.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在另一个资源中，可能包含了对其它资源的引用。在这种情况下，我们就需要在表示对其它资源进行引用的域中通过URL来标明被引用资源的位置。例如一件Dole果汁中，可能就需要包含对品牌Dole的引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    &quot;uri&quot; : &quot;/api/items/1438299&quot;,</span><br><span class="line">    &quot;label&quot; : &quot;Dole Grape Juice&quot;,</span><br><span class="line">    &quot;price&quot; : &quot;$3.99&quot;,</span><br><span class="line">    &quot;brand&quot; : &#123;</span><br><span class="line">       &quot;label&quot; : &quot;Dole&quot;</span><br><span class="line">       &quot;uri&quot; : &quot;/api/brands/32059&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的Dole果汁的表示中，我们可以看到它的brand域就是对品牌的引用。该引用中包含了该品牌的品牌名称以及一个指向该品牌的URL。</p><p>在一个基于HTTP的REST系统中，我们常常在资源的引用中包含一定量的描述信息。这主要因为两点：</p><ol><li>提高性能。在一个对资源的引用中添加了用于显示的属性后，客户端页面可以避免再次通过url发送请求得到资源的具体描述，以得到用于显示的信息。</li><li>自描述性的要求。如果一个资源中包含了一个对其它资源进行引用的数组，那么用户就需要通过该标签来决定到底访问哪个被引用的资源。</li></ol><p>当然，如果需要在展示Dole果汁的页面中需要Dole这个品牌的完整信息，我们也可以将它直接嵌到Dole果汁的表示中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;uri&quot; : &quot;/api/items/1438299&quot;,</span><br><span class="line">   &quot;label&quot; : &quot;Dole Grape Juice&quot;,</span><br><span class="line">   &quot;price&quot; : &quot;$3.99&quot;,</span><br><span class="line">   &quot;brand&quot; : &#123;</span><br><span class="line">    &quot;uri&quot; : &quot;/api/brands/32059&quot;,</span><br><span class="line">    &quot;label&quot; : &quot;Dole&quot;,</span><br><span class="line">    &quot;description&quot; : &quot;An American-based agricultural multinational corporation.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果一个资源的表示太过复杂，而且有些属性实际上是相互关联的，那么我们也可以通过一个属性将它们归结在一起：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    &quot;uri&quot; : &quot;/api/items/1438299&quot;,</span><br><span class="line">    &quot;label&quot; : &quot;Dole Grape Juice&quot;,</span><br><span class="line">    &quot;price&quot; : &quot;$3.99&quot;,</span><br><span class="line">    &quot;brand&quot; : &#123;</span><br><span class="line">       &quot;uri&quot; : &quot;/api/brands/32059&quot;,</span><br><span class="line">       &quot;label&quot; : &quot;Dole&quot;,</span><br><span class="line">       &quot;description&quot; : &quot;An American-based agricultural multinational corporation.&quot;</span><br><span class="line">   &#125;</span><br><span class="line">   &quot;nutrient component&quot; : &#123;</span><br><span class="line">      &quot;sugar&quot; : &quot;14.5&quot;,</span><br><span class="line">      &quot;protein&quot; : &quot;0.3&quot;,</span><br><span class="line">      &quot;fat&quot; : &quot;0.1&quot;</span><br><span class="line">   &#125;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的Dole果汁的表示中，我们使用域nutrient component来表示所有的营养成分，而该域内部的各个子域则用来表示一系列相关的营养成分所占比例。</p><p>另外，在不同的情况下，我们还可能对同一个资源提供不同的表现形式。例如在一个资源极为复杂，其JSON表示甚至可以达到几百K的时候，我们可以为该资源提供一个简化版本，以在非必要的情况下减少传输的数据量。</p><p>例如在egoods中，我们会将某些物美价廉的商品置于它的首页上，以吸引用户购买。在用户将鼠标移动到某个商品上并停留一段时间时，我们会为用户展示一个Tooltip，并在该Tooltip中展示该商品的一部分信息。在这种情况下，向服务端请求该商品的所有信息以展示Tooltip便显得有些效率低下了。</p><p>有时候，一个资源可能并不支持特定用户执行某个操作。例如一个管理员所创建的资源可能对普通用户只读。在这种情况下，我们需要禁止普通用户对该资源的修改和删除。为了能明确地告知用户他所具有的权限，我们需要一个能显式地标示用户可以在一个资源上所执行操作的组成。在REST响应中，这种组成被称为Hypermedia Controls。例如对于一个普通用户，其从egoods中所返回的分类列表将如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> HTTP/1.1 200 OK</span><br><span class="line"> Content-Type: application/json</span><br><span class="line"> Content-Length: xxx</span><br><span class="line">  </span><br><span class="line"> [</span><br><span class="line">    &#123;</span><br><span class="line">       &quot;label&quot; : &quot;Food&quot;,</span><br><span class="line">       &quot;uri&quot; : &quot;/api/categories/1&quot;,</span><br><span class="line">       &quot;actions&quot; : [&quot;GET&quot;]</span><br><span class="line">   &#125;, &#123;</span><br><span class="line">      &quot;label&quot; : &quot;Clothes&quot;,</span><br><span class="line">      &quot;uri&quot; : &quot;/api/categories/2&quot;,</span><br><span class="line">      &quot;actions&quot; : [&quot;GET&quot;]</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;label&quot; : &quot;Electronics&quot;,</span><br><span class="line">      &quot;uri&quot; : &quot;/api/categories/25&quot;,</span><br><span class="line">      &quot;actions&quot; : [&quot;GET&quot;]</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到，在上面的分类列表中，我们通过actions域显式地标示了用户可以在各个类别上所能执行的操作。而对于管理员，其还可以执行修改，删除等操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> HTTP/1.1 200 OK</span><br><span class="line"> Content-Type: application/json</span><br><span class="line"> Content-Length: xxx</span><br><span class="line">  </span><br><span class="line"> [</span><br><span class="line">    &#123;</span><br><span class="line">       &quot;label&quot; : &quot;Food&quot;,</span><br><span class="line">       &quot;uri&quot; : &quot;/api/categories/1&quot;,</span><br><span class="line">       &quot;actions&quot; : [&quot;GET&quot;, &quot;PUT&quot;, &quot;DELETE&quot;]</span><br><span class="line">   &#125;, &#123;</span><br><span class="line">      &quot;label&quot; : &quot;Clothes&quot;,</span><br><span class="line">      &quot;uri&quot; : &quot;/api/categories/2&quot;,</span><br><span class="line">      &quot;actions&quot; : [&quot;GET&quot;, &quot;PUT&quot;, &quot;DELETE&quot;]</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;label&quot; : &quot;Electronics&quot;,</span><br><span class="line">      &quot;uri&quot; : &quot;/api/categories/25&quot;,</span><br><span class="line">      &quot;actions&quot; : [&quot;GET&quot;, &quot;PUT&quot;, &quot;DELETE&quot;]</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>而在一系列较为著名的REST系统中，如Sun Cloud API，其更是通过Hypermedia Controls定义了除CRUD之外的动词。如对于一个虚拟机，其在运行状态下可以执行停止命令，而在停止状态下可以执行启动命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    &quot;vms&quot; : [</span><br><span class="line">       &#123;</span><br><span class="line">          &quot;id&quot; : &quot;1&quot;,</span><br><span class="line">          ......</span><br><span class="line">          &quot;status&quot; : &quot;stopped&quot;,</span><br><span class="line">          &quot;links&quot; : [</span><br><span class="line">             &#123;</span><br><span class="line">                &quot;rel&quot; : &quot;start&quot;,</span><br><span class="line">               &quot;method&quot; : &quot;post&quot;,</span><br><span class="line">               &quot;uri&quot; : &quot;vms/1?op=start&quot;</span><br><span class="line">            &#125;</span><br><span class="line">         ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">         &quot;id&quot; : &quot;2&quot;,</span><br><span class="line">         ......</span><br><span class="line">         &quot;status&quot; : &quot;started&quot;,</span><br><span class="line">         &quot;links&quot; : [</span><br><span class="line">            &#123;</span><br><span class="line">               &quot;rel&quot; : &quot;stop&quot;,</span><br><span class="line">               &quot;method&quot; : &quot;post&quot;,</span><br><span class="line">               &quot;uri&quot; : &quot;vms/2?op=stop&quot;</span><br><span class="line">            &#125;</span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是一个常见的观点是：如果一个资源需要除CRUD之外的额外的动词，那么这种需求常常表示我们对于某个资源的定义并不是十分合理。因此在遇到这种情况时，软件开发人员首先需要考虑为资源添加额外的动词是否合适。</p><h2 id="无状态约束"><a href="#无状态约束" class="headerlink" title="无状态约束"></a>无状态约束</h2><p>在Roy Fielding的论文中，其为REST添加了一个无状态约束：</p><p><em>We next add a constraint to the client-server interaction: communication must be stateless in nature … such that each request from client to server must contain all of the information necessary to understand the request, and cannot take advantage of any stored context on the server. Session state is therefore kept entirely on the client.</em></p><p>从上面的陈述中可以看到，在一个REST系统中，用户的状态会随着请求在客户端和服务端之间来回传递。这也便是REST这个缩写中ST（State Transfer）的来历。</p><p>为REST系统添加这个约束有什么好处呢？主要还是基于集群扩展性的考虑。如果REST服务中记录了用户相关的状态，那么在集群中，这些用户相关的状态就需要及时地在集群中的各个服务器之间同步。对用户状态的同步将会是一个非常棘手的问题：当一个用户的相关状态在一个服务器上发生了更改，那么在什么时候，什么情况下对这些状态进行同步？如果该状态同步是同步进行的，那么同时刷新多个服务器上的用户状态将导致对用户请求的处理变得异常缓慢。如果该同步是异步的，那么用户在发送下一个请求时，其它服务器将可能由于用户状态不同步的原因无法正确地处理用户的请求。除此之外，如果集群进行了不停机的横向扩展，那么用户状态的同步需要如何完成？这些实际上都是非常难以处理的问题。</p><p>但是现有的很多较为流行的技术及规范实际上都没有限制用户的请求是无状态的。相信您知道，一个技术或规范实际上都拥有一个生态圈。在该生态圈之内的各技术之间可以较好地契合在一起。尤其是，有些技术实际上就会以该生态圈中的核心技术或规范所建立的假设之上来实现自己的功能。如果希望禁止该假设，那么让某些技术工作起来就是非常困难的事情了。</p><p>就以搭建基于HTTP的REST服务为例。在HTTP中，一个重要的功能就是Cookie和Session的使用（RFC6265）。该功能会在服务器里保留一个状态。因此在一个基于HTTP的REST系统中，我们常常需要避免使用这些在服务器里面保留状态的技术。但是某些技术，如用户的登陆，实际上常常需要在服务器中添加一个状态。</p><p>所以在stackoverflow中，我们常常会看到有人问：我现在使用了这样一种解决方案。这样实现是不是RESTful？此时一些人就会说，这不是RESTful。但是pure RESTful和almost RESTful之间的区别主要还是在于一个是理论，一个是工程。在工程中，轻微地违反了一个准则并不一定代表这个解决方案一无是处。而是要看遵守该准则和轻微地违反了该准则之后工作量的大小以及后期的维护成本：之所以提出一系列准则，那是因为遵守该准则拥有一定的好处。如果对该准则的轻微违反可以减少大量的工作量，而且遵守准则的好处并没有消失，或者是通过另一样技术可以快速地重新获得该好处，那么对准则的轻微违反是值得的。</p><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>其实在上一节中，我们已经提出了无状态约束给REST实现带来的麻烦：用户的状态是需要全部保存在客户端的。当用户需要执行某个操作的时候，其需要将所有的执行该请求所需要的信息添加到请求中。该请求将可能被REST服务集群中的任意服务器处理，而不需要担心该服务器中是否存有用户相关的状态。</p><p>但是在现有的各种基于HTTP的Web服务中，我们常常使用会话来管理用户状态，至少是用户的登陆状态。因此，REST系统的无状态约束实际上并不是一个对传统用户登录功能友好的约束：在传统登陆过程中，其本身就是通过用户所提供的用户名和密码等在服务端创建一个用户的登陆状态，而REST的无状态约束为了横向扩展性却不想要这种状态。而这也就是为基于HTTP的REST服务添加身份验证功能的困难之处。</p><p>为了解决该问题，最为经典也最符合REST规范的实现是在每次发送请求的时候都将用户的用户名和密码都发送给服务器。而服务器将根据请求中的用户名和密码调用登陆服务，以从该服务中得到用户所对应的Identity和其所具有的权限。接下来，在REST服务中根据用户的权限来访问资源。</p><p><img src="http://images0.cnblogs.com/blog2015/126867/201507/222357513181643.png" alt="img"></p><p>这里有一个问题就是登陆的性能。随着系统当前的加密算法越来越复杂，登陆已经不再是一个轻量级的操作。因此用户所发送的每次请求都要求一次登陆对于整个系统而言就是一个巨大的瓶颈。</p><p>在当前，解决该问题的方法主要是一个独立的缓存系统，如整个集群唯一的登陆服务器。但是缓存系统本身所存储的仍然是用户的登陆状态。因此该解决方案将仍然轻微地违反了REST的无状态约束。</p><p>还有一个类似的方法是通过添加一个代理来完成的。该代理会完成用户的登陆并获得该用户所拥有的权限。接下来，该代理会将与状态有关的信息从请求中删除，并添加用户的权限信息。在经过了这种处理之后，这些请求就可以转发到其后的各个服务器上了。转发目的地所在的服务器则会假设所有传入的请求都是合法的并直接对这些请求进行处理。</p><p><img src="http://images0.cnblogs.com/blog2015/126867/201507/222358437872847.png" alt="img"></p><p>可以看到，无论是一个独立的登陆服务器还是为整个集群添加一个代理，系统中都将有一个地方保留了用户的登陆状态。这实际上和在集群中对会话集中进行管理并没有什么不同。也就是说，我们所尝试的通过禁止使用会话来达成完全的无状态并不现实。因此在一个基于HTTP的REST服务中，为登陆功能使用集中管理的会话是合理的。</p><p>既然我们放松了对REST系统的无状态约束，那么一个REST系统所可以使用的登陆机制将主要分为以下两种：</p><ol><li>基于HTTPS的Basic Access Authentication</li></ol><p>其好处是其易于实现，而且主流的浏览器都提供了对该功能的支持。但是由于登陆窗口都是由浏览器所提供的，因此其与产品外观有很大不同。除此之外，浏览器都没有提供登出的功能，也没有提供找回密码等功能。</p><ol><li>基于Cookie及Session的管理</li></ol><p>在使用Cookie来管理用户的注册状态的时候，其实际上就是将服务端所返回的Cookie在每次发送请求的时候添加到请求中。虽然说这个Cookie并非存储了用户应用的状态，但是其实际存储了用户的登陆状态。因此客户端的角度来讲，由服务端管理的Session并不符合REST所倡导的无状态的要求。</p><p>可以说，上面的两种方法各有优劣。可能第二种方法从客户端的角度看来并不是RESTful的，但是其优势则在于很多类库都直接提供了对该功能的支持，从而简化了会话管理服务器的实现。</p><p>在这里顺便提一句，如果项目足够大，将一些SSO产品集成到服务中也是不错的选择。</p><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>在前面已经提到过，一个REST系统为资源所抽象出的URI实际上是对用户的一种承诺。但反过来说，软件开发人员也很难预知一个资源的各方面特征如何在未来发生变化，从而提供一个永远不变的URI。</p><p>在一个REST系统逐渐发展的过程中，新的属性，新的资源将逐渐被添加到该系统中。在这些更改过程中，资源的URI，访问资源的动词，响应中的Status Code将不能发生变化。此时软件开发人员所做的工作就是在现有系统上维护REST API的后向兼容性。</p><p>当资源发生了过多的变化，原有的URI设计已经很难兼容现有资源应有的定义时，软件开发人员就需要考虑是否应该提供一个新版本的REST API。那么我们该如何对资源的版本进行管理呢？</p><p>首先要考虑的就是，新API的版本信息是否应当包含在资源的URI中。这在各著名论坛中仍然是一个争议较大的话题。一种观点认为在不同版本的API中，一个资源拥有不同的地址在一定程度上违反了HATEOAS：URI只是用来指定一个资源所在的位置，而不是该资源如何被抽象。如果一个资源由不同的URI标示其不同的表现形式，那么用户将无法通过一个响应中所标示的URI得到其它URI所指向的表示形式。而且在URI中添加了有关版本的信息也就标示着其可能会随着时间的推移发生变化。</p><p>一种使用独立URI的方法是基于Accept头。在一个请求中，我们常常标明了Accept头，以标示客户端希望得到的表现形式。在该头中，用户可以添加所请求的资源的版本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /api/categories/1</span><br><span class="line">Host: www.egoods.com</span><br><span class="line">Authorization: Basic xxxxxxxxxxxxxxxxxxx</span><br><span class="line">Accept: application/vnd.ambergarden.egoods-v3+json</span><br></pre></td></tr></table></figure><p>而在接收到该请求之后，服务端将返回该资源的第三个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/vnd.ambergarden.egoods-v3+json</span><br><span class="line">Content-Length: xxx</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">   &quot;uri&quot; : &quot;/api/categories/1&quot;,</span><br><span class="line">   &quot;label&quot; : &quot;Food&quot;,</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该方法是非常严格地遵守REST系统所提出的约束的。但其也并不是没有缺点：添加一个自定义MIME类型（Custom MIME Type）也是一个很麻烦的流程，而且在很多现有技术中都没有很好地支持它，如HTML5中的Form。因此这种方案的缺点是对REST API用户并不那么友好。</p><p>除此之外，另一种基于重定向的解决方案也被提出。该方案允许一个REST系统提供多个版本的API，并在URI中标明版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/api/v2/categories</span><br><span class="line">/api/v1/categories</span><br></pre></td></tr></table></figure><p>这样用户可以选择使用特定版本的REST API来实现客户端功能。由于其使用固定版本的API，因此并不存在着一个资源有多种表示，进而违反了HATEOAS约束的问题。</p><p>在REST系统的API随时间逐渐发展出众多版本的时候，系统对API的维护也将成为一个较大的问题。此时就需要逐渐退役一些年代久远的API 版本。对这些版本的退役主要分为两步：首先将其标为过期的，但是还在一段时间内支持。在这种情况下，对这些已经过期的API的访问将得到3XX响应，如301 Moved Permanently，以通知用户该URI所标示的资源需要使用新版本的URI进行访问。而再经过一段时间后，则将过期的REST API标记为废弃的。此时用户在访问这些URI时将返回4XX响应，如410 Gone。</p><p>接下来，该REST系统还可以提供一个通用的REST API接口，并与最新版本的API保持一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/categories</span><br></pre></td></tr></table></figure><p>这样用户还可以选择一直使用最新版本的API，只是同时也需要一直对其进行维护，以保持与最新版本API的兼容性。在REST系统的API随着时间的推移逐渐发生变化的时候，该客户端也需要逐渐更新自身的功能。</p><p>但是该方法有一个问题：由通用URI所辨识出的各个资源需要是稳定的，不能在一定时间之后被废弃，否则会给用户带来非常大的维护性的麻烦。举例来说，假设客户端逻辑添加了一系列操作分类的功能。当REST系统决定不再采用分类作为商品归类的标准，那么客户端逻辑中与分类相关的各个功能都需要进行大幅度地修改。过于频繁的这种改动很容易导致用户对该系统所提供的API失去维护的信心。因此在抽象资源时一定要努力地将各个资源的边界辨识清楚。虽然说这听起来很吓人，但是在经过仔细考虑后这种情况还是较为容易避免的。</p><p>但是反过来说，理论常常与实际有些脱钩，更何况REST是在2000年左右提出的，无法做到能够预见到十余年后所使用的各项技术。因此在尽量符合REST所提出的各约束上提供一个最直观的，具有最高易用性的API才是王道。无限制地提供后向兼容性是一个非常困难，成本非常高的事情。因此在版本管理这一方面上来说，我们也需要尽量兼顾项目需求和完全遵从理论这两者之间的平衡。</p><p>而在同一个版本之中，我们则需要保证API的后向兼容性。也就是说，在添加新的资源以及为资源添加新的属性的时候，原有的对资源进行操作的API也应该是工作的。</p><p>对于一个基于HTTP的REST服务而言，软件开发人员需要遵守如下的守则以保持API的后向兼容性：</p><ol><li>不能在请求中添加新的必须的参数。</li><li>不能更改操作资源的动词。</li><li>不能更改响应的HTTP status。</li></ol><p>而前向兼容性则显得没有那么重要了。REST服务的前向兼容性要求现有的服务兼容未来版本服务的客户端。但是由于服务提供商所提供的服务常常是最新版本，因此对前向兼容性有要求的情况很少出现。另外一点是，为一个服务提供前向兼容性其实并不那么容易。因为这要求软件开发人员对产品的未来方向进行非常多的假设，而且这些假设不能有错误。反过来，这种对服务的前向兼容性的要求主要由客户端自身通过保持后向兼容性来完成。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>接下来我们就来简单地说说基于HTTP的REST服务中的性能问题。在基于HTTP的REST服务中，性能提升主要分为两个方面：REST架构本身在提高性能方面做出的努力，以及基于HTTP协议的优化。</p><p>首先要讨论的就是对登陆性能的优化。在前面我们已经介绍过，在一个基于HTTP的REST服务中，每次都将用户的用户名和密码发送到服务端并由服务端验证这些信息是否合法是一个非常消耗资源的流程。因此我们常常需要在登陆服务中使用一个缓存，或者是使用第三方单点登陆（SSO）类库。</p><p>除此之外，软件开发人员还可以通过为同一个资源提供不同的表现形式来减少在网络上传输的数据量，从而提高REST服务的性能。</p><p>而在集群内部服务之间，我们则可以不再使用JSON，XML等这种用户可以读懂的负载格式，而是使用二进制格式。这样可以大大地减少内部网络所需要传输的数据量。这在内部网络交换数据频繁并且所传输的数据量巨大时较为有效。</p><p>接下来就是REST系统的横向扩展。在REST的无状态约束的支持下，我们可以很容易地向REST系统中添加一个新的服务器。</p><p>除了这些和REST架构本身相关的性能提升之外，我们还可以在如何更高效地使用HTTP协议上努力。一个最常见的方法就是使用条件请求（Conditional Request）。简单地说，我们可以使用如下的HTTP头来有条件地存取资源：</p><ol><li>ETag：一个对用户不透明的用来标示资源实例的哈希值</li><li>Data-Modified：资源被更改的时间</li><li>If-Modified-Since：根据资源的更改时间有条件地Get资源。这将允许客户端对未更改的资源使用本地缓存。</li><li>If-None-Match：根据ETag的值有条件地Get资源。</li><li>If-Unmodified-Since：根据资源的更改时间有条件地Put或Delete资源。</li><li>If-Match：根据ETag的值有条件地Put或Delete资源。</li></ol><p>当然，这里所提到的一系列性能优化方案实际上仅仅是比较常见的，与基于HTTP的REST服务关联较大的方案。只是顾虑到过多地陈述和REST关联不大的话题一方面显得比较没有效率，另一方面也是因为通过写另一个系列博客可以将问题陈述得更加清楚，因此在这里我们将不再继续讨论性能相关的话题。</p><p>下一节不出意外将会给大家带来一个实例demo来帮助大家进一步理解REST。</p>]]></content>
    
    <summary type="html">
    
      之前介绍了RESTful相关的基础介绍，现在在来谈谈相关的其他介绍，帮助大家进一步了解
    
    </summary>
    
      <category term="架构" scheme="http://yushiyang.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="php" scheme="http://yushiyang.top/tags/php/"/>
    
      <category term="RESTful" scheme="http://yushiyang.top/tags/RESTful/"/>
    
      <category term="转载" scheme="http://yushiyang.top/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>IE ajax请求乱码问题</title>
    <link href="http://yushiyang.top/2017/10/11/IE-bug/"/>
    <id>http://yushiyang.top/2017/10/11/IE-bug/</id>
    <published>2017-10-11T06:17:57.000Z</published>
    <updated>2017-10-12T02:43:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在写一个小功能时遇到了一个小问题，在谷歌浏览器中没有问题，但却在IE中保存不正确，第一时间想到的就是编码问题，最后证实，的确是因为IE浏览器对ajax的参数的汉字编码不相同</p><p>为了避免乱码，网上也查找了些，有以下方法：</p><ol><li><p>使用POST请求而不是GET请求</p><ul><li>GET 请求是会通过链接来传递参数，而且是自动urlEncode（编码），而IE貌似是用iso-8859-1来编码，而其他的浏览器基本没问题就是utf-8，所以会出现IE编码乱码的问题，使用POST请求就不会出现这种问题</li><li>使用get时尽量不要使用中文，使用中文保险起见还是post比较靠谱</li></ul></li><li><p>要是你使用的是POST请求还是出现乱码，可能就是编码不统一了，文件编码，数据库编码，网页编码统一utf-8编码</p></li><li><p>还有一种就是比较麻烦的解决方式（我没试，感兴趣的可以试试）</p><p>undefined客户端：</p><p>  encodeURI(url)</p><p>  服务端（服务器默认编码为ISO-8859-1）：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String test = new String(request.getParameter(&quot;test“).getBytes(ISO-8859-1), &quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure><p>  URL编解码过程：</p><p>  UTF-8(encodeURI())编码 -&gt;  ISO-8859-1(服务器)解码 -&gt; getBytes(ISO-8859-1)编码 -&gt; UTF-8解码。</p><p>  ​</p></li><li><p>还有一种就是全局设定contentType(不过我试过好像没什么用，不知道是不是我用的方法写错了)</p><ul><li>因为jquery ajax是使用utf-8编码发送数据的。IE发送时没加上这个，所以我们人为加上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajaxSetup(&#123;</span><br><span class="line">  contentType:&quot;application/x-www-form-urlencode; charset=utf-8&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  ​</p></li></ol><p>嗯，一个很小的注意点，我觉得还是都用POST比较省事，如果对性能什么的很注重的话，需要GET，那就需要另寻他法，如果使用POST请求就不会出现IE乱码问题！</p>]]></content>
    
    <summary type="html">
    
      一个小小的注意点，关于ajax请求参数在IE 中文编码问题
    
    </summary>
    
      <category term="前端" scheme="http://yushiyang.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="原创" scheme="http://yushiyang.top/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="js" scheme="http://yushiyang.top/tags/js/"/>
    
      <category term="php" scheme="http://yushiyang.top/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>RESTful(一)</title>
    <link href="http://yushiyang.top/2017/10/10/restful-%E4%B8%80/"/>
    <id>http://yushiyang.top/2017/10/10/restful-一/</id>
    <published>2017-10-10T06:01:47.000Z</published>
    <updated>2017-10-12T01:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RESTful是什么"><a href="#RESTful是什么" class="headerlink" title="RESTful是什么"></a>RESTful是什么</h2><h3 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h3><p>一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件，它主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更加简洁，更有层次。更易于实现缓存机制。</p><h3 id="简单的说"><a href="#简单的说" class="headerlink" title="简单的说"></a>简单的说</h3><p>官方标准说法我表示我是从来没看懂过得，用一些高大上的晦涩的词汇，什么事RESTful呢，简单的说就是由于现在各种各样的客户端太多了，我们不可能像以前那样前后端写在一起，那样成本太高，因此我们需要设计一套API来供人家调用，而我们要做的就是根据相应的规则设计一套API来供他人调用。</p><p>我的理解就是一句话：根据http协议相关的标准来设计API，统一URL风格。</p><h2 id="理解RESTful"><a href="#理解RESTful" class="headerlink" title="理解RESTful"></a>理解RESTful</h2><p>看URL就知道要什么，看http method就知道干什么，看http status code就知道放回结果如何</p><ul><li><p>资源与URL</p></li><li><p>统一资源接口</p></li></ul><h3 id="资源与URL"><a href="#资源与URL" class="headerlink" title="资源与URL"></a>资源与URL</h3><p>所谓资源就是我们需要获取的数据，可以是用户列表，或者某个用户的信息等等</p><p>所谓URL就是每个资源都对应一个URL，一看URL就知道你需要哪个资源比如：</p><ul><li><a href="http://www.imooc.com/learn/901" target="_blank" rel="noopener">http://www.imooc.com/learn/901</a></li></ul><h3 id="统一资源接口"><a href="#统一资源接口" class="headerlink" title="统一资源接口"></a>统一资源接口</h3><p>对于资源的具体操作类型，由HTTP动词表示。</p><p><strong>http动词</strong>：</p><ul><li>GET：从服务器中取出资源。</li><li>POST： 在服务器新建一个资源。</li><li>PUT： 在服务器更新资源（客户端提供修改后的数据）。</li><li>PATCH：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE：从服务器删除资源</li></ul><p>还有两个不常用的Http动词：</p><ul><li>HEAD：获取资源的元数据</li><li>OPTIONS：获取信息，关于资源的哪些属性客户端可以改变的</li></ul><p>下面是一些例子：</p><ul><li>GET /student 列出所有的学生</li><li>POST /student 新加入一个学生</li><li>GET /student/id  获取某个学生的信息</li><li>PUT /student/id 更新某个指定学生全部的信息（客户端提供要更新的学生的全部信息）</li><li>PATCH /student/id 更新某个指定学生的部分信息</li><li>DELETE /student/id 删除某个指定学生</li></ul><p><strong>状态码（常用）</strong>：</p><ul><li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li><li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li><li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li><li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li><li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li><li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li><li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li><li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li><li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li><li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li><li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li><li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li></ul><p>状态码的完全列表在<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">这里</a></p><p>小结：到这里，基本的URl表现形式和返回码就已经很清楚了，清楚了这个以后我们设计的API URL将不再是无意义的字符串，而是见名知义，下一节我们将介绍资源的表述形式。</p>]]></content>
    
    <summary type="html">
    
      随着现在越来越多的客户端涌现，传统的web模式已经不再适用，前后端分离的模式也越来越重要，接下来的几篇文章将是一个系列，来讲述RESTful架构的相关知识。
    
    </summary>
    
      <category term="架构" scheme="http://yushiyang.top/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="原创" scheme="http://yushiyang.top/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="php" scheme="http://yushiyang.top/tags/php/"/>
    
      <category term="RESTful" scheme="http://yushiyang.top/tags/RESTful/"/>
    
  </entry>
  
  <entry>
    <title>php实现单向链表解决约瑟夫环问题</title>
    <link href="http://yushiyang.top/2017/10/10/yueshefu/"/>
    <id>http://yushiyang.top/2017/10/10/yueshefu/</id>
    <published>2017-10-10T03:18:42.000Z</published>
    <updated>2017-10-10T03:56:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文转载<a href="http://blog.csdn.net/mxdzchallpp/article/details/51777371" target="_blank" rel="noopener">php实现单向链表解决约瑟夫环问题</a></p><p>约瑟夫环问题：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。</p><p>更多的类似问题是：n个人围成圈，依次编号为1,2,..,n，现在从1号开始依次报数，当报到m时，报m的人退出，下一个人重新从1报起，循环下去，问最后剩下那个人的编号是多少？</p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line"></span><br><span class="line">class Node&#123;  </span><br><span class="line"></span><br><span class="line">    public $value;      // 节点值  </span><br><span class="line">    public $nextNode;   // 下一个节点  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">function create($node, $value)&#123;  </span><br><span class="line">    $node-&gt;value = $value;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">function addNode($node, $value)&#123;  </span><br><span class="line">    $lastNode = findLastNode($node);  </span><br><span class="line">    $nextNode = new Node();  </span><br><span class="line">    $nextNode-&gt;value = $value;  </span><br><span class="line">    $lastNode-&gt;nextNode = $nextNode;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">/* 找到最后的节点 */  </span><br><span class="line">function findLastNode($node)&#123;  </span><br><span class="line">    if(empty($node-&gt;nextNode))&#123;  </span><br><span class="line">        return $node;  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">        return findLastNode($node-&gt;nextNode);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">/* 删除节点 必须head为引用传值 */  </span><br><span class="line">function deleteNode(&amp;$head, $node, $m, $k = 1)&#123;  </span><br><span class="line">    if($k + 1 == $m)&#123;  </span><br><span class="line">        if($node-&gt;nextNode == $head)&#123;  </span><br><span class="line">            $node-&gt;nextNode = $node-&gt;nextNode-&gt;nextNode;  </span><br><span class="line">            $head = $node-&gt;nextNode;  </span><br><span class="line">            return $node-&gt;nextNode;  </span><br><span class="line">        &#125;else&#123;  </span><br><span class="line">            $node-&gt;nextNode = $node-&gt;nextNode-&gt;nextNode;  </span><br><span class="line">            return $node-&gt;nextNode;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">        return deleteNode($head, $node-&gt;nextNode, $m, ++$k);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">/* 节点数 */  </span><br><span class="line">function countNode($head, $node, $count = 1)&#123;  </span><br><span class="line">    if($node-&gt;nextNode == $head)&#123;  </span><br><span class="line">        return $count;  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">        return countNode($head, $node-&gt;nextNode, ++$count);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">function printNode($head, $node)&#123;  </span><br><span class="line">    echo $node-&gt;value . &apos;  &apos;;  </span><br><span class="line">    if($node-&gt;nextNode == $head) return;  </span><br><span class="line">    printNode($head, $node-&gt;nextNode);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">function show($data)&#123;  </span><br><span class="line">    echo &apos;&lt;pre&gt;&apos;;  </span><br><span class="line">    print_r($data);  </span><br><span class="line">    echo &apos;&lt;/pre&gt;&apos;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">$head = new Node();  </span><br><span class="line">create($head, 1);  </span><br><span class="line"></span><br><span class="line">addNode($head, 2);  </span><br><span class="line">addNode($head, 3);  </span><br><span class="line">addNode($head, 4);  </span><br><span class="line">addNode($head, 5);  </span><br><span class="line">addNode($head, 6);  </span><br><span class="line">addNode($head, 7);  </span><br><span class="line">addNode($head, 8);  </span><br><span class="line">addNode($head, 9);  </span><br><span class="line">addNode($head, 10);  </span><br><span class="line">addNode($head, 11);  </span><br><span class="line">addNode($head, 12);</span><br><span class="line">addNode($head, 13);  </span><br><span class="line">addNode($head, 14);</span><br><span class="line">addNode($head, 15);  </span><br><span class="line">addNode($head, 16);</span><br><span class="line">addNode($head, 17);  </span><br><span class="line">addNode($head, 18);</span><br><span class="line">addNode($head, 19);  </span><br><span class="line">addNode($head, 20);</span><br><span class="line">addNode($head, 21);  </span><br><span class="line">addNode($head, 22);</span><br><span class="line">addNode($head, 23);  </span><br><span class="line">addNode($head, 24);  </span><br><span class="line">$lastNode = findLastNode($head);  </span><br><span class="line">$lastNode-&gt;nextNode = $head;  </span><br><span class="line"></span><br><span class="line">$count = countNode($head, $head);  </span><br><span class="line">$tmpHead = $head;  </span><br><span class="line">while ($count &gt; 2) &#123;  </span><br><span class="line">    $tmpHead = deleteNode($head, $tmpHead, 3, 1);  </span><br><span class="line">    $count = countNode($head, $head);  </span><br><span class="line">&#125;  </span><br><span class="line">printNode($head, $head);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      一个好玩的算法利用php解决约瑟夫环问题，单向链表！
    
    </summary>
    
      <category term="php" scheme="http://yushiyang.top/categories/php/"/>
    
    
      <category term="算法" scheme="http://yushiyang.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="php" scheme="http://yushiyang.top/tags/php/"/>
    
      <category term="转载" scheme="http://yushiyang.top/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>php上传图片到七牛</title>
    <link href="http://yushiyang.top/2017/09/28/update-qiniu/"/>
    <id>http://yushiyang.top/2017/09/28/update-qiniu/</id>
    <published>2017-09-28T06:45:10.000Z</published>
    <updated>2017-09-28T07:38:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着对项目要求的不断提高，相信现在很多人都会把图片单独存储，而七牛就是个很不错的选择</p><p>因为是个小demo，我就废话不多说了，3步走：</p><ul><li>首先你得需要创建一个七牛的账号（获取秘钥管理中的AccessKey·SecretKey和你的存储空间名字）。</li><li>接下来就是下载七牛的 <a href="https://github.com/qiniu/php-sdk/tags" target="_blank" rel="noopener">phpsdk</a>。</li><li>最后一步当然就是代码咯</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    require_once __DIR__ . &apos;/qiniu/autoload.php&apos;;//我把下载的七牛sdk重新命名位qinniu </span><br><span class="line">    // 引入鉴权类</span><br><span class="line">    use Qiniu\Auth;</span><br><span class="line">    // 引入上传类</span><br><span class="line">    use Qiniu\Storage\UploadManager;</span><br><span class="line">    // 需要填写你的 Access Key 和 Secret Key</span><br><span class="line">    $accessKey = &apos;...&apos;;</span><br><span class="line">    $secretKey = &apos;...&apos;;</span><br><span class="line">    // 构建鉴权对象</span><br><span class="line">    $auth = new Auth($accessKey, $secretKey);</span><br><span class="line">    // 你自己的要上传的空间</span><br><span class="line">    $bucket = &apos;...&apos;;</span><br><span class="line">    // 生成上传 Token</span><br><span class="line">    $token = $auth-&gt;uploadToken($bucket);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;图片上传&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form method=&quot;post&quot; action=&quot;http://up.qiniu.com&quot; enctype=&quot;multipart/form-data&quot;&gt;  </span><br><span class="line">        &lt;input name=&quot;token&quot; type=&quot;hidden&quot; value=&quot;&lt;?php echo $token;?&gt;&quot;&gt;  </span><br><span class="line">        &lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;  </span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;  </span><br><span class="line">    &lt;/form&gt; </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>到这，再去登录你的七牛查看，应该就会有你刚上传的图像了<br>怎么样，简单吧，最基础的上传图片就已经ok了</p>]]></content>
    
    <summary type="html">
    
      一个简单的小demo，具体应用到项目中还需调整，原理大概就是这样，可以轻松的上传图片到七牛
    
    </summary>
    
      <category term="php" scheme="http://yushiyang.top/categories/php/"/>
    
    
      <category term="原创" scheme="http://yushiyang.top/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="php" scheme="http://yushiyang.top/tags/php/"/>
    
      <category term="七牛" scheme="http://yushiyang.top/tags/%E4%B8%83%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>说在前面</title>
    <link href="http://yushiyang.top/2017/09/28/talk-front/"/>
    <id>http://yushiyang.top/2017/09/28/talk-front/</id>
    <published>2017-09-28T03:30:41.000Z</published>
    <updated>2017-10-12T01:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到我的博客，这也是我下定决心以来后搭建的第一个小博客，希望在今后的日子里面能和大家一起交流学习。</p><h2 id="为什么要搭建这样一个博客"><a href="#为什么要搭建这样一个博客" class="headerlink" title="为什么要搭建这样一个博客"></a>为什么要搭建这样一个博客</h2><h3 id="为什么要选择hexo来搭建博客"><a href="#为什么要选择hexo来搭建博客" class="headerlink" title="为什么要选择hexo来搭建博客"></a>为什么要选择hexo来搭建博客</h3><p>现在写博客的地方有很多。有的人会说，csdn，简书等等很多地方都可以来写博客，方便，省事，为什么还要自己搭建一个博客呢？的确，现在很多地方都能写博客，但可能是个人因素吧，想要自己搭建一个小博客，一来是可以装装b~(^o^)~。二来相对成本也比较低，基本一天就可以搭建，修改样式全部完成。而且是博客是依托在github上的，免费的服务器，一分钱都不用花（嘿嘿，不花钱的都是好的）。学习成本低，而且好看，免费，有个性，何乐而不为呢。<br><a id="more"></a></p><h3 id="为什么想起来要写博客"><a href="#为什么想起来要写博客" class="headerlink" title="为什么想起来要写博客"></a>为什么想起来要写博客</h3><p>以前也总想着写来着，一直也当回事认真去做，总觉的浪费时间，现在想来觉得做技术的人写写东西还是又必要的。</p><ul><li>俗话说好记性不如烂笔头，及时的记录可以方便以后的查看。</li><li>很多时候一个问题并不是真的弄懂了，只不过是误打误撞最后的结果对了，记录问题时有利于梳理一下相关的知识点，说不定本来有点晕的东西最后就变成了自己东西。</li><li>当然，不止为了自己，分享对于做技术的那是相当的重要，查看他人的博客对技术的提升是非常大的，要是没有博客，一上来就只有官方文档之类的东西，我相信那就是真的 <strong>从入门到放弃了</strong>。</li></ul><h2 id="对于这个博客，以后的想法"><a href="#对于这个博客，以后的想法" class="headerlink" title="对于这个博客，以后的想法"></a>对于这个博客，以后的想法</h2><h3 id="主要写点什么"><a href="#主要写点什么" class="headerlink" title="主要写点什么"></a>主要写点什么</h3><p>因为自己目前还是个大四学生，对于写作，技术等各个方面都有所不足，能写出什么很nb的东西也不太可能，只想做好自己，记录生活，记录平时遇到的觉得有必要记录的小问题，以及相关的解决方法。</p><ol><li>目前正在一家公司实习，主要是做php的，主要会记录一点工作做遇到的问题，以及相关的解决方法。</li><li>从开始做web端，到前端h5，nodejs等等，再到现在的web后端php，趁自己还年轻也想着做点改变，学点其他的东西，于是就选择了目前很火的机器学习，所以平时估计也会更新一点python，机器学习的相关文章，当然，那只是班门弄斧，难登大雅之堂的小东西。</li><li>技术方面可能主要就以上面为主了，当然看到有什么好玩的小东西，或者看到不错的文章，我也很更新转载，注明出处，感兴趣的小伙伴也可以去了解了解，有时候碰到的一些小工具真的是挺有趣的<strong>（比如这个博客hexo）</strong>。</li><li>除了技术方面，我也会偶尔更新一下生活琐事，就当写日记了（感觉比读书时候还认真，哈哈~），到时候欢迎大家来阅读</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>嗯~，作为一个理科生，我已经写不下去了….总之，希望大家以后多交流，技术上面，生活方面有问题随时都可以联系我，我知道的看到后会第一时间回复，初入社会的小白一枚，在技术上也是入门级的小白，希望能够相互学习，交流，这也是我创建这个博客的初衷把，好了，就这样吧，我实在实在是不知道说些什么啦！！！</p>]]></content>
    
    <summary type="html">
    
      为什么要搭建这样一个博客，以及对以后的想法之类的，谁便说说,欢迎大家来到我的博客
    
    </summary>
    
      <category term="生活" scheme="http://yushiyang.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="原创" scheme="http://yushiyang.top/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="生活杂文" scheme="http://yushiyang.top/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E6%96%87/"/>
    
  </entry>
  
</feed>
